<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\BadRequest;
use \ccxt\InvalidAddress;
use \ccxt\InvalidOrder;
use \ccxt\NotSupported;
use \ccxt\Precise;

class okex extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'okex',
            'name' => 'OKEX',
            'countries' => array( 'CN', 'US' ),
            'version' => 'v5',
            'rateLimit' => 100,
            'pro' => true,
            'certified' => true,
            'has' => array(
                'margin' => true,
                'swap' => true,
                'future' => true,
                'addMargin' => true,
                'cancelOrder' => true,
                'CORS' => null,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchBorrowRate' => true,
                'fetchBorrowRates' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingHistory' => true,
                'fetchFundingRate' => true,
                'fetchFundingRateHistory' => true,
                'fetchIndexOHLCV' => true,
                'fetchLedger' => true,
                'fetchLeverage' => true,
                'fetchMarkets' => true,
                'fetchMarketsByType' => true,
                'fetchMarkOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTickersByType' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchTradingFee' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => true,
                'setLeverage' => true,
                'setMarginMode' => true,
                'setPositionMode' => true,
                'transfer' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1H',
                '2h' => '2H',
                '4h' => '4H',
                '6h' => '6Hutc',
                '12h' => '12Hutc',
                '1d' => '1Dutc',
                '1w' => '1Wutc',
                '1M' => '1Mutc',
                '3M' => '3Mutc',
                '6M' => '6Mutc',
                '1y' => '1Yutc',
            ),
            'hostname' => 'www.okex.com',
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg',
                'api' => array(
                    'rest' => 'https://{hostname}',
                ),
                'www' => 'https://www.okex.com',
                'doc' => 'https://www.okex.com/docs-v5/en/',
                'fees' => 'https://www.okex.com/pages/products/fees.html',
                // 'referral' => 'https://www.okex.com/join/1888677',
                'test' => array(
                    'rest' => 'https://testnet.okex.com',
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'market/tickers' => 1,
                        'market/ticker' => 1,
                        'market/index-tickers' => 1,
                        'market/books' => 1,
                        'market/candles' => 1,
                        'market/history-candles' => 1,
                        'market/index-candles' => 1,
                        'market/mark-price-candles' => 1,
                        'market/trades' => 1,
                        'market/platform-24-volume' => 10,
                        'market/open-oracle' => 100,
                        'market/index-components' => 1,
                        // 'market/oracle',
                        'public/instruments' => 1,
                        'public/delivery-exercise-history' => 0.5,
                        'public/open-interest' => 1,
                        'public/funding-rate' => 1,
                        'public/funding-rate-history' => 1,
                        'public/price-limit' => 1,
                        'public/opt-summary' => 1,
                        'public/estimated-price' => 2,
                        'public/discount-rate-interest-free-quota' => 10,
                        'public/time' => 2,
                        'public/liquidation-orders' => 0.5,
                        'public/mark-price' => 2,
                        // 'public/tier',
                        'public/position-tiers' => 2,
                        'public/underlying' => 1,
                        'public/interest-rate-loan-quota' => 10,
                        'rubik/stat/trading-data/support-coin' => 4,
                        'rubik/stat/taker-volume' => 4,
                        'rubik/stat/margin/loan-ratio' => 4,
                        // long/short
                        'rubik/stat/contracts/long-short-account-ratio' => 4,
                        'rubik/stat/contracts/open-interest-volume' => 4,
                        'rubik/stat/option/open-interest-volume' => 4,
                        // put/call
                        'rubik/stat/option/open-interest-volume-ratio' => 4,
                        'rubik/stat/option/open-interest-volume-expiry' => 4,
                        'rubik/stat/option/open-interest-volume-strike' => 4,
                        'rubik/stat/option/taker-block-volume' => 4,
                        'system/status' => 100,
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'account/account-position-risk' => 2,
                        'account/balance' => 2,
                        'account/positions' => 2,
                        'account/bills' => 5 / 3,
                        'account/bills-archive' => 5 / 3,
                        'account/config' => 4,
                        'account/max-size' => 1,
                        'account/max-avail-size' => 1,
                        'account/leverage-info' => 1,
                        'account/max-loan' => 1,
                        'account/trade-fee' => 4,
                        'account/interest-accrued' => 4,
                        'account/interest-rate' => 4,
                        'account/max-withdrawal' => 1,
                        'asset/deposit-address' => 5 / 3,
                        'asset/balances' => 5 / 3,
                        'asset/transfer-state' => 10,
                        'asset/deposit-history' => 5 / 3,
                        'asset/withdrawal-history' => 5 / 3,
                        'asset/currencies' => 5 / 3,
                        'asset/bills' => 5 / 3,
                        'asset/piggy-balance' => 5 / 3,
                        'asset/deposit-lightning' => 5,
                        'trade/order' => 1 / 3,
                        'trade/orders-pending' => 1,
                        'trade/orders-history' => 0.5,
                        'trade/orders-history-archive' => 1,
                        'trade/fills' => 1 / 3,
                        'trade/fills-history' => 2,
                        'trade/orders-algo-pending' => 1,
                        'trade/orders-algo-history' => 1,
                        'account/subaccount/balances' => 10,
                        'asset/subaccount/bills' => 5 / 3,
                        'users/subaccount/list' => 10,
                        'users/subaccount/apikey' => 10,
                    ),
                    'post' => array(
                        'account/set-position-mode' => 4,
                        'account/set-leverage' => 1,
                        'account/position/margin-balance' => 1,
                        'account/set-greeks' => 4,
                        'asset/transfer' => 10,
                        'asset/withdrawal' => 5 / 3,
                        'asset/purchase_redempt' => 5 / 3,
                        'asset/withdrawal-lightning' => 5,
                        'trade/order' => 1 / 3,
                        'trade/batch-orders' => 1 / 15,
                        'trade/cancel-order' => 1 / 3,
                        'trade/cancel-batch-orders' => 1 / 15,
                        'trade/amend-order' => 1 / 3,
                        'trade/amend-batch-orders' => 1 / 3,
                        'trade/close-position' => 1,
                        'trade/order-algo' => 1,
                        'trade/cancel-algos' => 1,
                        'trade/cancel-advance-algos' => 1,
                        'users/subaccount/delete-apikey' => 10,
                        'users/subaccount/modify-apikey' => 10,
                        'users/subaccount/apikey' => 10,
                        'asset/subaccount/transfer' => 10,
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'taker' => $this->parse_number('0.0015'),
                    'maker' => $this->parse_number('0.0010'),
                ),
                'spot' => array(
                    'taker' => $this->parse_number('0.0015'),
                    'maker' => $this->parse_number('0.0010'),
                ),
                'futures' => array(
                    'taker' => $this->parse_number('0.0005'),
                    'maker' => $this->parse_number('0.0002'),
                ),
                'swap' => array(
                    'taker' => $this->parse_number('0.00050'),
                    'maker' => $this->parse_number('0.00020'),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
                'password' => true,
            ),
            'exceptions' => array(
                'exact' => array(
                    // Public error codes from 50000-53999
                    // General Class
                    '1' => '\\ccxt\\ExchangeError', // Operation failed
                    '2' => '\\ccxt\\ExchangeError', // Bulk operation partially succeeded
                    '50000' => '\\ccxt\\BadRequest', // Body can not be empty
                    '50001' => '\\ccxt\\OnMaintenance', // Matching engine upgrading. Please try again later
                    '50002' => '\\ccxt\\BadRequest', // Json data format error
                    '50004' => '\\ccxt\\RequestTimeout', // Endpoint request timeout (does not indicate success or failure of order, please check order status)
                    '50005' => '\\ccxt\\ExchangeNotAvailable', // API is offline or unavailable
                    '50006' => '\\ccxt\\BadRequest', // Invalid Content_Type, please use "application/json" format
                    '50007' => '\\ccxt\\AccountSuspended', // Account blocked
                    '50008' => '\\ccxt\\AuthenticationError', // User does not exist
                    '50009' => '\\ccxt\\AccountSuspended', // Account is suspended due to ongoing liquidation
                    '50010' => '\\ccxt\\ExchangeError', // User ID can not be empty
                    '50011' => '\\ccxt\\RateLimitExceeded', // Request too frequent
                    '50012' => '\\ccxt\\ExchangeError', // Account status invalid
                    '50013' => '\\ccxt\\ExchangeNotAvailable', // System is busy, please try again later
                    '50014' => '\\ccxt\\ExchangeError', // Parameter {0} can not be empty
                    '50015' => '\\ccxt\\ExchangeError', // Either parameter {0} or {1} is required
                    '50016' => '\\ccxt\\ExchangeError', // Parameter {0} does not match parameter {1}
                    '50017' => '\\ccxt\\ExchangeError', // The position is frozen due to ADL. Operation restricted
                    '50018' => '\\ccxt\\ExchangeError', // Currency {0} is frozen due to ADL. Operation restricted
                    '50019' => '\\ccxt\\ExchangeError', // The account is frozen due to ADL. Operation restricted
                    '50020' => '\\ccxt\\ExchangeError', // The position is frozen due to liquidation. Operation restricted
                    '50021' => '\\ccxt\\ExchangeError', // Currency {0} is frozen due to liquidation. Operation restricted
                    '50022' => '\\ccxt\\ExchangeError', // The account is frozen due to liquidation. Operation restricted
                    '50023' => '\\ccxt\\ExchangeError', // Funding fee frozen. Operation restricted
                    '50024' => '\\ccxt\\ExchangeError', // Parameter {0} and {1} can not exist at the same time
                    '50025' => '\\ccxt\\ExchangeError', // Parameter {0} count exceeds the limit {1}
                    '50026' => '\\ccxt\\ExchangeError', // System error
                    '50027' => '\\ccxt\\ExchangeError', // The account is restricted from trading
                    '50028' => '\\ccxt\\ExchangeError', // Unable to take the order, please reach out to support center for details
                    // API Class
                    '50100' => '\\ccxt\\ExchangeError', // API frozen, please contact customer service
                    '50101' => '\\ccxt\\ExchangeError', // Broker id of APIKey does not match current environment
                    '50102' => '\\ccxt\\InvalidNonce', // Timestamp request expired
                    '50103' => '\\ccxt\\AuthenticationError', // Request header "OK_ACCESS_KEY" can not be empty
                    '50104' => '\\ccxt\\AuthenticationError', // Request header "OK_ACCESS_PASSPHRASE" can not be empty
                    '50105' => '\\ccxt\\AuthenticationError', // Request header "OK_ACCESS_PASSPHRASE" incorrect
                    '50106' => '\\ccxt\\AuthenticationError', // Request header "OK_ACCESS_SIGN" can not be empty
                    '50107' => '\\ccxt\\AuthenticationError', // Request header "OK_ACCESS_TIMESTAMP" can not be empty
                    '50108' => '\\ccxt\\ExchangeError', // Exchange ID does not exist
                    '50109' => '\\ccxt\\ExchangeError', // Exchange domain does not exist
                    '50110' => '\\ccxt\\PermissionDenied', // Invalid IP
                    '50111' => '\\ccxt\\AuthenticationError', // Invalid OK_ACCESS_KEY
                    '50112' => '\\ccxt\\AuthenticationError', // Invalid OK_ACCESS_TIMESTAMP
                    '50113' => '\\ccxt\\AuthenticationError', // Invalid signature
                    '50114' => '\\ccxt\\AuthenticationError', // Invalid authorization
                    '50115' => '\\ccxt\\BadRequest', // Invalid request method
                    // Trade Class
                    '51000' => '\\ccxt\\BadRequest', // Parameter {0} error
                    '51001' => '\\ccxt\\BadSymbol', // Instrument ID does not exist
                    '51002' => '\\ccxt\\BadSymbol', // Instrument ID does not match underlying index
                    '51003' => '\\ccxt\\BadRequest', // Either client order ID or order ID is required
                    '51004' => '\\ccxt\\InvalidOrder', // Order amount exceeds current tier limit
                    '51005' => '\\ccxt\\InvalidOrder', // Order amount exceeds the limit
                    '51006' => '\\ccxt\\InvalidOrder', // Order price out of the limit
                    '51007' => '\\ccxt\\InvalidOrder', // Order placement failed. Order amount should be at least 1 contract (showing up when placing an order with less than 1 contract)
                    '51008' => '\\ccxt\\InsufficientFunds', // Order placement failed due to insufficient balance
                    '51009' => '\\ccxt\\AccountSuspended', // Order placement function is blocked by the platform
                    '51010' => '\\ccxt\\InsufficientFunds', // Account level too low
                    '51011' => '\\ccxt\\InvalidOrder', // Duplicated order ID
                    '51012' => '\\ccxt\\ExchangeError', // Token does not exist
                    '51014' => '\\ccxt\\ExchangeError', // Index does not exist
                    '51015' => '\\ccxt\\BadSymbol', // Instrument ID does not match instrument type
                    '51016' => '\\ccxt\\InvalidOrder', // Duplicated client order ID
                    '51017' => '\\ccxt\\ExchangeError', // Borrow amount exceeds the limit
                    '51018' => '\\ccxt\\ExchangeError', // User with option account can not hold net short positions
                    '51019' => '\\ccxt\\ExchangeError', // No net long positions can be held under isolated margin mode in options
                    '51020' => '\\ccxt\\InvalidOrder', // Order amount should be greater than the min available amount
                    '51021' => '\\ccxt\\BadSymbol', // Contract to be listed
                    '51022' => '\\ccxt\\BadSymbol', // Contract suspended
                    '51023' => '\\ccxt\\ExchangeError', // Position does not exist
                    '51024' => '\\ccxt\\AccountSuspended', // Unified accountblocked
                    '51025' => '\\ccxt\\ExchangeError', // Order count exceeds the limit
                    '51026' => '\\ccxt\\BadSymbol', // Instrument type does not match underlying index
                    '51027' => '\\ccxt\\BadSymbol', // Contract expired
                    '51028' => '\\ccxt\\BadSymbol', // Contract under delivery
                    '51029' => '\\ccxt\\BadSymbol', // Contract is being settled
                    '51030' => '\\ccxt\\BadSymbol', // Funding fee is being settled
                    '51031' => '\\ccxt\\InvalidOrder', // This order price is not within the closing price range
                    '51100' => '\\ccxt\\InvalidOrder', // Trading amount does not meet the min tradable amount
                    '51101' => '\\ccxt\\InvalidOrder', // Entered amount exceeds the max pending order amount (Cont) per transaction
                    '51102' => '\\ccxt\\InvalidOrder', // Entered amount exceeds the max pending count
                    '51103' => '\\ccxt\\InvalidOrder', // Entered amount exceeds the max pending order count of the underlying asset
                    '51104' => '\\ccxt\\InvalidOrder', // Entered amount exceeds the max pending order amount (Cont) of the underlying asset
                    '51105' => '\\ccxt\\InvalidOrder', // Entered amount exceeds the max order amount (Cont) of the contract
                    '51106' => '\\ccxt\\InvalidOrder', // Entered amount exceeds the max order amount (Cont) of the underlying asset
                    '51107' => '\\ccxt\\InvalidOrder', // Entered amount exceeds the max holding amount (Cont)
                    '51108' => '\\ccxt\\InvalidOrder', // Positions exceed the limit for closing out with the market price
                    '51109' => '\\ccxt\\InvalidOrder', // No available offer
                    '51110' => '\\ccxt\\InvalidOrder', // You can only place a limit order after Call Auction has started
                    '51111' => '\\ccxt\\BadRequest', // Maximum {0} orders can be placed in bulk
                    '51112' => '\\ccxt\\InvalidOrder', // Close order size exceeds your available size
                    '51113' => '\\ccxt\\RateLimitExceeded', // Market-price liquidation requests too frequent
                    '51115' => '\\ccxt\\InvalidOrder', // Cancel all pending close-orders before liquidation
                    '51116' => '\\ccxt\\InvalidOrder', // Order price or trigger price exceeds {0}
                    '51117' => '\\ccxt\\InvalidOrder', // Pending close-orders count exceeds limit
                    '51118' => '\\ccxt\\InvalidOrder', // Total amount should exceed the min amount per order
                    '51119' => '\\ccxt\\InsufficientFunds', // Order placement failed due to insufficient balance
                    '51120' => '\\ccxt\\InvalidOrder', // Order quantity is less than {0}, please try again
                    '51121' => '\\ccxt\\InvalidOrder', // Order count should be the integer multiples of the lot size
                    '51122' => '\\ccxt\\InvalidOrder', // Order price should be higher than the min price {0}
                    '51124' => '\\ccxt\\InvalidOrder', // You can only place limit orders during call auction
                    '51125' => '\\ccxt\\InvalidOrder', // Currently there are reduce . reverse position pending orders in margin trading. Please cancel all reduce . reverse position pending orders and continue
                    '51126' => '\\ccxt\\InvalidOrder', // Currently there are reduce only pending orders in margin trading.Please cancel all reduce only pending orders and continue
                    '51127' => '\\ccxt\\InsufficientFunds', // Available balance is 0
                    '51128' => '\\ccxt\\InvalidOrder', // Multi-currency margin account can not do cross-margin trading
                    '51129' => '\\ccxt\\InvalidOrder', // The value of the position and buy order has reached the position limit, and no further buying is allowed
                    '51130' => '\\ccxt\\BadSymbol', // Fixed margin currency error
                    '51131' => '\\ccxt\\InsufficientFunds', // Insufficient balance
                    '51132' => '\\ccxt\\InvalidOrder', // Your position amount is negative and less than the minimum trading amount
                    '51133' => '\\ccxt\\InvalidOrder', // Reduce-only feature is unavailable for the spot transactions by multi-currency margin account
                    '51134' => '\\ccxt\\InvalidOrder', // Closing failed. Please check your holdings and pending orders
                    '51135' => '\\ccxt\\InvalidOrder', // Your closing price has triggered the limit price, and the max buy price is {0}
                    '51136' => '\\ccxt\\InvalidOrder', // Your closing price has triggered the limit price, and the min sell price is {0}
                    '51137' => '\\ccxt\\InvalidOrder', // Your opening price has triggered the limit price, and the max buy price is {0}
                    '51138' => '\\ccxt\\InvalidOrder', // Your opening price has triggered the limit price, and the min sell price is {0}
                    '51139' => '\\ccxt\\InvalidOrder', // Reduce-only feature is unavailable for the spot transactions by simple account
                    '51201' => '\\ccxt\\InvalidOrder', // Value of per market order cannot exceed 100,000 USDT
                    '51202' => '\\ccxt\\InvalidOrder', // Market - order amount exceeds the max amount
                    '51203' => '\\ccxt\\InvalidOrder', // Order amount exceeds the limit {0}
                    '51204' => '\\ccxt\\InvalidOrder', // The price for the limit order can not be empty
                    '51205' => '\\ccxt\\InvalidOrder', // Reduce-Only is not available
                    '51250' => '\\ccxt\\InvalidOrder', // Algo order price is out of the available range
                    '51251' => '\\ccxt\\InvalidOrder', // Algo order type error (when user place an iceberg order)
                    '51252' => '\\ccxt\\InvalidOrder', // Algo order price is out of the available range
                    '51253' => '\\ccxt\\InvalidOrder', // Average amount exceeds the limit of per iceberg order
                    '51254' => '\\ccxt\\InvalidOrder', // Iceberg average amount error (when user place an iceberg order)
                    '51255' => '\\ccxt\\InvalidOrder', // Limit of per iceberg order => Total amount/1000 < x <= Total amount
                    '51256' => '\\ccxt\\InvalidOrder', // Iceberg order price variance error
                    '51257' => '\\ccxt\\InvalidOrder', // Trail order callback rate error
                    '51258' => '\\ccxt\\InvalidOrder', // Trail - order placement failed. The trigger price of a sell order should be higher than the last transaction price
                    '51259' => '\\ccxt\\InvalidOrder', // Trail - order placement failed. The trigger price of a buy order should be lower than the last transaction price
                    '51260' => '\\ccxt\\InvalidOrder', // Maximum {0} pending trail - orders can be held at the same time
                    '51261' => '\\ccxt\\InvalidOrder', // Each user can hold up to {0} pending stop - orders at the same time
                    '51262' => '\\ccxt\\InvalidOrder', // Maximum {0} pending iceberg orders can be held at the same time
                    '51263' => '\\ccxt\\InvalidOrder', // Maximum {0} pending time-weighted orders can be held at the same time
                    '51264' => '\\ccxt\\InvalidOrder', // Average amount exceeds the limit of per time-weighted order
                    '51265' => '\\ccxt\\InvalidOrder', // Time-weighted order limit error
                    '51267' => '\\ccxt\\InvalidOrder', // Time-weighted order strategy initiative rate error
                    '51268' => '\\ccxt\\InvalidOrder', // Time-weighted order strategy initiative range error
                    '51269' => '\\ccxt\\InvalidOrder', // Time-weighted order interval error, the interval should be {0}<= x<={1}
                    '51270' => '\\ccxt\\InvalidOrder', // The limit of time-weighted order price variance is 0 < x <= 1%
                    '51271' => '\\ccxt\\InvalidOrder', // Sweep ratio should be 0 < x <= 100%
                    '51272' => '\\ccxt\\InvalidOrder', // Price variance should be 0 < x <= 1%
                    '51273' => '\\ccxt\\InvalidOrder', // Total amount should be more than {0}
                    '51274' => '\\ccxt\\InvalidOrder', // Total quantity of time-weighted order must be larger than single order limit
                    '51275' => '\\ccxt\\InvalidOrder', // The amount of single stop-market order can not exceed the upper limit
                    '51276' => '\\ccxt\\InvalidOrder', // Stop - Market orders cannot specify a price
                    '51277' => '\\ccxt\\InvalidOrder', // TP trigger price can not be higher than the last price
                    '51278' => '\\ccxt\\InvalidOrder', // SL trigger price can not be lower than the last price
                    '51279' => '\\ccxt\\InvalidOrder', // TP trigger price can not be lower than the last price
                    '51280' => '\\ccxt\\InvalidOrder', // SL trigger price can not be higher than the last price
                    '51400' => '\\ccxt\\OrderNotFound', // Cancellation failed as the order does not exist
                    '51401' => '\\ccxt\\OrderNotFound', // Cancellation failed as the order is already canceled
                    '51402' => '\\ccxt\\OrderNotFound', // Cancellation failed as the order is already completed
                    '51403' => '\\ccxt\\InvalidOrder', // Cancellation failed as the order type does not support cancellation
                    '51404' => '\\ccxt\\InvalidOrder', // Order cancellation unavailable during the second phase of call auction
                    '51405' => '\\ccxt\\ExchangeError', // Cancellation failed as you do not have any pending orders
                    '51406' => '\\ccxt\\ExchangeError', // Canceled - order count exceeds the limit {0}
                    '51407' => '\\ccxt\\BadRequest', // Either order ID or client order ID is required
                    '51408' => '\\ccxt\\ExchangeError', // Pair ID or name does not match the order info
                    '51409' => '\\ccxt\\ExchangeError', // Either pair ID or pair name ID is required
                    '51410' => '\\ccxt\\CancelPending', // Cancellation failed as the order is already under cancelling status
                    '51500' => '\\ccxt\\ExchangeError', // Either order price or amount is required
                    '51501' => '\\ccxt\\ExchangeError', // Maximum {0} orders can be modified
                    '51502' => '\\ccxt\\InsufficientFunds', // Order modification failed for insufficient margin
                    '51503' => '\\ccxt\\ExchangeError', // Order modification failed as the order does not exist
                    '51506' => '\\ccxt\\ExchangeError', // Order modification unavailable for the order type
                    '51508' => '\\ccxt\\ExchangeError', // Orders are not allowed to be modified during the call auction
                    '51509' => '\\ccxt\\ExchangeError', // Modification failed as the order has been canceled
                    '51510' => '\\ccxt\\ExchangeError', // Modification failed as the order has been completed
                    '51511' => '\\ccxt\\ExchangeError', // Modification failed as the order price did not meet the requirement for Post Only
                    '51600' => '\\ccxt\\ExchangeError', // Status not found
                    '51601' => '\\ccxt\\ExchangeError', // Order status and order ID cannot exist at the same time
                    '51602' => '\\ccxt\\ExchangeError', // Either order status or order ID is required
                    '51603' => '\\ccxt\\OrderNotFound', // Order does not exist
                    // Data class
                    '52000' => '\\ccxt\\ExchangeError', // No updates
                    // SPOT/MARGIN error codes 54000-54999
                    '54000' => '\\ccxt\\ExchangeError', // Margin transactions unavailable
                    '54001' => '\\ccxt\\ExchangeError', // Only Multi-currency margin account can be set to borrow coins automatically
                    // FUNDING error codes 58000-58999
                    '58000' => '\\ccxt\\ExchangeError', // Account type {0} does not supported when getting the sub-account balance
                    '58001' => '\\ccxt\\AuthenticationError', // Incorrect trade password
                    '58002' => '\\ccxt\\PermissionDenied', // Please activate Savings Account first
                    '58003' => '\\ccxt\\ExchangeError', // Currency type is not supported by Savings Account
                    '58004' => '\\ccxt\\AccountSuspended', // Account blocked (transfer & withdrawal endpoint => either end of the account does not authorize the transfer)
                    '58005' => '\\ccxt\\ExchangeError', // The redeemed amount must be no greater than {0}
                    '58006' => '\\ccxt\\ExchangeError', // Service unavailable for token {0}
                    '58007' => '\\ccxt\\ExchangeError', // Abnormal Assets interface. Please try again later
                    '58100' => '\\ccxt\\ExchangeError', // The trading product triggers risk control, and the platform has suspended the fund transfer-out function with related users. Please wait patiently
                    '58101' => '\\ccxt\\AccountSuspended', // Transfer suspended (transfer endpoint => either end of the account does not authorize the transfer)
                    '58102' => '\\ccxt\\RateLimitExceeded', // Too frequent transfer (transfer too frequently)
                    '58103' => '\\ccxt\\ExchangeError', // Parent account user id does not match sub-account user id
                    '58104' => '\\ccxt\\ExchangeError', // Since your P2P transaction is abnormal, you are restricted from making fund transfers. Please contact customer support to remove the restriction
                    '58105' => '\\ccxt\\ExchangeError', // Since your P2P transaction is abnormal, you are restricted from making fund transfers. Please transfer funds on our website or app to complete identity verification
                    '58106' => '\\ccxt\\ExchangeError', // Please enable the account for spot contract
                    '58107' => '\\ccxt\\ExchangeError', // Please enable the account for futures contract
                    '58108' => '\\ccxt\\ExchangeError', // Please enable the account for option contract
                    '58109' => '\\ccxt\\ExchangeError', // Please enable the account for swap contract
                    '58110' => '\\ccxt\\ExchangeError', // The contract triggers risk control, and the platform has suspended the fund transfer function of it. Please wait patiently
                    '58111' => '\\ccxt\\ExchangeError', // Funds transfer unavailable as the perpetual contract is charging the funding fee. Please try again later
                    '58112' => '\\ccxt\\ExchangeError', // Your fund transfer failed. Please try again later
                    '58114' => '\\ccxt\\ExchangeError', // Transfer amount must be more than 0
                    '58115' => '\\ccxt\\ExchangeError', // Sub-account does not exist
                    '58116' => '\\ccxt\\ExchangeError', // Transfer amount exceeds the limit
                    '58117' => '\\ccxt\\ExchangeError', // Account assets are abnormal, please deal with negative assets before transferring
                    '58200' => '\\ccxt\\ExchangeError', // Withdrawal from {0} to {1} is unavailable for this currency
                    '58201' => '\\ccxt\\ExchangeError', // Withdrawal amount exceeds the daily limit
                    '58202' => '\\ccxt\\ExchangeError', // The minimum withdrawal amount for NEO is 1, and the amount must be an integer
                    '58203' => '\\ccxt\\InvalidAddress', // Please add a withdrawal address
                    '58204' => '\\ccxt\\AccountSuspended', // Withdrawal suspended
                    '58205' => '\\ccxt\\ExchangeError', // Withdrawal amount exceeds the upper limit
                    '58206' => '\\ccxt\\ExchangeError', // Withdrawal amount is lower than the lower limit
                    '58207' => '\\ccxt\\InvalidAddress', // Withdrawal failed due to address error
                    '58208' => '\\ccxt\\ExchangeError', // Withdrawal failed. Please link your email
                    '58209' => '\\ccxt\\ExchangeError', // Withdrawal failed. Withdraw feature is not available for sub-accounts
                    '58210' => '\\ccxt\\ExchangeError', // Withdrawal fee exceeds the upper limit
                    '58211' => '\\ccxt\\ExchangeError', // Withdrawal fee is lower than the lower limit (withdrawal endpoint => incorrect fee)
                    '58212' => '\\ccxt\\ExchangeError', // Withdrawal fee should be {0}% of the withdrawal amount
                    '58213' => '\\ccxt\\AuthenticationError', // Please set trading password before withdrawal
                    '58300' => '\\ccxt\\ExchangeError', // Deposit-address count exceeds the limit
                    '58350' => '\\ccxt\\InsufficientFunds', // Insufficient balance
                    // Account error codes 59000-59999
                    '59000' => '\\ccxt\\ExchangeError', // Your settings failed as you have positions or open orders
                    '59001' => '\\ccxt\\ExchangeError', // Switching unavailable as you have borrowings
                    '59100' => '\\ccxt\\ExchangeError', // You have open positions. Please cancel all open positions before changing the leverage
                    '59101' => '\\ccxt\\ExchangeError', // You have pending orders with isolated positions. Please cancel all the pending orders and adjust the leverage
                    '59102' => '\\ccxt\\ExchangeError', // Leverage exceeds the maximum leverage. Please adjust the leverage
                    '59103' => '\\ccxt\\InsufficientFunds', // Leverage is too low and no sufficient margin in your account. Please adjust the leverage
                    '59104' => '\\ccxt\\ExchangeError', // The leverage is too high. The borrowed position has exceeded the maximum position of this leverage. Please adjust the leverage
                    '59105' => '\\ccxt\\ExchangeError', // Leverage can not be less than {0}. Please adjust the leverage
                    '59106' => '\\ccxt\\ExchangeError', // The max available margin corresponding to your order tier is {0}. Please adjust your margin and place a new order
                    '59107' => '\\ccxt\\ExchangeError', // You have pending orders under the service, please modify the leverage after canceling all pending orders
                    '59108' => '\\ccxt\\InsufficientFunds', // Low leverage and insufficient margin, please adjust the leverage
                    '59109' => '\\ccxt\\ExchangeError', // Account equity less than the required margin amount after adjustment. Please adjust the leverage
                    '59200' => '\\ccxt\\InsufficientFunds', // Insufficient account balance
                    '59201' => '\\ccxt\\InsufficientFunds', // Negative account balance
                    '59300' => '\\ccxt\\ExchangeError', // Margin call failed. Position does not exist
                    '59301' => '\\ccxt\\ExchangeError', // Margin adjustment failed for exceeding the max limit
                    '59401' => '\\ccxt\\ExchangeError', // Holdings already reached the limit
                    '59500' => '\\ccxt\\ExchangeError', // Only the APIKey of the main account has permission
                    '59501' => '\\ccxt\\ExchangeError', // Only 50 APIKeys can be created per account
                    '59502' => '\\ccxt\\ExchangeError', // Note name cannot be duplicate with the currently created APIKey note name
                    '59503' => '\\ccxt\\ExchangeError', // Each APIKey can bind up to 20 IP addresses
                    '59504' => '\\ccxt\\ExchangeError', // The sub account does not support the withdrawal function
                    '59505' => '\\ccxt\\ExchangeError', // The passphrase format is incorrect
                    '59506' => '\\ccxt\\ExchangeError', // APIKey does not exist
                    '59507' => '\\ccxt\\ExchangeError', // The two accounts involved in a transfer must be two different sub accounts under the same parent account
                    '59508' => '\\ccxt\\AccountSuspended', // The sub account of {0} is suspended
                    // WebSocket error Codes from 60000-63999
                    '60001' => '\\ccxt\\AuthenticationError', // "OK_ACCESS_KEY" can not be empty
                    '60002' => '\\ccxt\\AuthenticationError', // "OK_ACCESS_SIGN" can not be empty
                    '60003' => '\\ccxt\\AuthenticationError', // "OK_ACCESS_PASSPHRASE" can not be empty
                    '60004' => '\\ccxt\\AuthenticationError', // Invalid OK_ACCESS_TIMESTAMP
                    '60005' => '\\ccxt\\AuthenticationError', // Invalid OK_ACCESS_KEY
                    '60006' => '\\ccxt\\InvalidNonce', // Timestamp request expired
                    '60007' => '\\ccxt\\AuthenticationError', // Invalid sign
                    '60008' => '\\ccxt\\AuthenticationError', // Login is not supported for public channels
                    '60009' => '\\ccxt\\AuthenticationError', // Login failed
                    '60010' => '\\ccxt\\AuthenticationError', // Already logged in
                    '60011' => '\\ccxt\\AuthenticationError', // Please log in
                    '60012' => '\\ccxt\\BadRequest', // Illegal request
                    '60013' => '\\ccxt\\BadRequest', // Invalid args
                    '60014' => '\\ccxt\\RateLimitExceeded', // Requests too frequent
                    '60015' => '\\ccxt\\NetworkError', // Connection closed as there was no data transmission in the last 30 seconds
                    '60016' => '\\ccxt\\ExchangeNotAvailable', // Buffer is full, cannot write data
                    '60017' => '\\ccxt\\BadRequest', // Invalid url path
                    '60018' => '\\ccxt\\BadRequest', // The {0} {1} {2} {3} {4} does not exist
                    '60019' => '\\ccxt\\BadRequest', // Invalid op {op}
                    '63999' => '\\ccxt\\ExchangeError', // Internal system error
                ),
                'broad' => array(
                ),
            ),
            'httpExceptions' => array(
                '429' => '\\ccxt\\ExchangeNotAvailable', // https://github.com/ccxt/ccxt/issues/9612
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'defaultNetwork' => 'ERC20',
                'networks' => array(
                    'ETH' => 'ERC20',
                    'TRX' => 'TRC20',
                    'OMNI' => 'Omni',
                ),
                'layerTwo' => array(
                    'Lightning' => true,
                    'Liquid' => true,
                ),
                'fetchOHLCV' => array(
                    // 'type' => 'Candles', // Candles or HistoryCandles, IndexCandles, MarkPriceCandles
                ),
                'createOrder' => 'privatePostTradeBatchOrders', // or 'privatePostTradeOrder'
                'createMarketBuyOrderRequiresPrice' => false,
                'fetchMarkets' => array( 'spot', 'futures', 'swap', 'option' ), // spot, futures, swap, option
                'defaultType' => 'spot', // 'funding', 'spot', 'margin', 'futures', 'swap', 'option'
                // 'fetchBalance' => array(
                //     'type' => 'spot', // 'funding', 'trading', 'spot'
                // ),
                'fetchLedger' => array(
                    'method' => 'privateGetAccountBills', // privateGetAccountBillsArchive, privateGetAssetBills
                ),
                // 1 = SPOT, 3 = FUTURES, 5 = MARGIN, 6 = FUNDING, 9 = SWAP, 12 = OPTION, 18 = Unified account
                'accountsByType' => array(
                    'spot' => '1',
                    'futures' => '3',
                    'margin' => '5',
                    'funding' => '6',
                    'swap' => '9',
                    'option' => '12',
                    'trading' => '18', // unified trading account
                    'unified' => '18',
                ),
                'typesByAccount' => array(
                    '1' => 'spot',
                    '3' => 'futures',
                    '5' => 'margin',
                    '6' => 'funding',
                    '9' => 'swap',
                    '12' => 'option',
                    '18' => 'trading', // unified trading account
                ),
                'brokerId' => 'e847386590ce4dBC',
            ),
            'commonCurrencies' => array(
                // OKEX refers to ERC20 version of Aeternity (AEToken)
                'AE' => 'AET', // https://github.com/ccxt/ccxt/issues/4981
                'BOX' => 'DefiBox',
                'HOT' => 'Hydro Protocol',
                'HSR' => 'HC',
                'MAG' => 'Maggie',
                'SBTC' => 'Super Bitcoin',
                'TRADE' => 'Unitrade',
                'YOYO' => 'YOYOW',
                'WIN' => 'WinToken', // https://github.com/ccxt/ccxt/issues/5701
            ),
        ));
    }

    public function fetch_status($params = array ()) {
        $response = yield $this->publicGetSystemStatus ($params);
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             array(
        //                 "begin":"1621328400000",
        //                 "end":"1621329000000",
        //                 "href":"https://www.okex.com/support/hc/en-us/articles/360060882172",
        //                 "scheDesc":"",
        //                 "serviceType":"1", // 0 WebSocket, 1 Spot/Margin, 2 Futures, 3 Perpetual, 4 Options, 5 Trading service
        //                 "state":"scheduled", // ongoing, completed, canceled
        //                 "system":"classic", // classic, unified
        //                 "title":"Classic Spot System Upgrade"
        //             ),
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $timestamp = $this->milliseconds();
        $update = array(
            'info' => $response,
            'updated' => $timestamp,
            'status' => 'ok',
            'eta' => null,
        );
        for ($i = 0; $i < count($data); $i++) {
            $event = $data[$i];
            $state = $this->safe_string($event, 'state');
            if ($state === 'ongoing') {
                $update['eta'] = $this->safe_integer($event, 'end');
                $update['status'] = 'maintenance';
            }
        }
        $this->status = array_merge($this->status, $update);
        return $this->status;
    }

    public function fetch_time($params = array ()) {
        $response = yield $this->publicGetPublicTime ($params);
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             array("ts":"1621247923668")
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0, array());
        return $this->safe_integer($first, 'ts');
    }

    public function fetch_markets($params = array ()) {
        $types = $this->safe_value($this->options, 'fetchMarkets');
        $result = array();
        for ($i = 0; $i < count($types); $i++) {
            $markets = yield $this->fetch_markets_by_type($types[$i], $params);
            $result = $this->array_concat($result, $markets);
        }
        return $result;
    }

    public function parse_markets($markets) {
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $result[] = $this->parse_market($markets[$i]);
        }
        return $result;
    }

    public function parse_market($market) {
        //
        //     {
        //         "alias":"", // this_week, next_week, quarter, next_quarter
        //         "baseCcy":"BTC",
        //         "category":"1",
        //         "ctMult":"",
        //         "ctType":"", // $inverse, $linear
        //         "ctVal":"",
        //         "ctValCcy":"",
        //         "expTime":"",
        //         "instId":"BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //         "instType":"SPOT", // SPOT, FUTURES, SWAP, OPTION
        //         "lever":"10",
        //         "listTime":"1548133413000",
        //         "lotSz":"0.00000001",
        //         "minSz":"0.00001",
        //         "optType":"",
        //         "quoteCcy":"USDT",
        //         "settleCcy":"",
        //         "state":"live",
        //         "stk":"",
        //         "tickSz":"0.1",
        //         "uly":""
        //     }
        //
        //     {
        //         alias => "",
        //         baseCcy => "",
        //         category => "1",
        //         ctMult => "0.1",
        //         ctType => "",
        //         ctVal => "1",
        //         ctValCcy => "BTC",
        //         expTime => "1648195200000",
        //         instId => "BTC-USD-220325-194000-P",
        //         instType => "OPTION",
        //         lever => "",
        //         listTime => "1631262612280",
        //         lotSz => "1",
        //         minSz => "1",
        //         optType => "P",
        //         quoteCcy => "",
        //         settleCcy => "BTC",
        //         state => "live",
        //         stk => "194000",
        //         tickSz => "0.0005",
        //         uly => "BTC-USD"
        //     }
        //
        $id = $this->safe_string($market, 'instId');
        $type = $this->safe_string_lower($market, 'instType');
        $spot = ($type === 'spot');
        $futures = ($type === 'futures');
        $swap = ($type === 'swap');
        $option = ($type === 'option');
        $contract = $swap || $futures || $option;
        $baseId = $this->safe_string($market, 'baseCcy');
        $quoteId = $this->safe_string($market, 'quoteCcy');
        $settleCurrency = $this->safe_string($market, 'settleCcy');
        $settle = $this->safe_currency_code($settleCurrency);
        $underlying = $this->safe_string($market, 'uly');
        if (($underlying !== null) && !$spot) {
            $parts = explode('-', $underlying);
            $baseId = $this->safe_string($parts, 0);
            $quoteId = $this->safe_string($parts, 1);
        }
        $inverse = $baseId === $settleCurrency;
        $linear = $quoteId === $settleCurrency;
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        $symbol = $base . '/' . $quote;
        $expiry = null;
        if ($contract) {
            $symbol = $symbol . ':' . $settle;
            $expiry = $this->safe_integer($market, 'expTime');
            if ($expiry !== null) {
                $ymd = $this->yymmdd($expiry);
                $symbol = $symbol . '-' . $ymd;
            }
            if ($option) {
                $strikePrice = $this->safe_string($market, 'stk');
                $optionType = $this->safe_string($market, 'optType');
                $symbol = $symbol . '-' . $strikePrice . '-' . $optionType;
            }
        }
        $tickSize = $this->safe_string($market, 'tickSz');
        $precision = array(
            'amount' => $this->safe_number($market, 'lotSz'),
            'price' => $this->parse_number($tickSize),
        );
        $minAmountString = $this->safe_string($market, 'minSz');
        $minAmount = $this->parse_number($minAmountString);
        $minCost = null;
        if (($minAmount !== null) && ($tickSize !== null)) {
            $minCost = $this->parse_number(Precise::string_mul($tickSize, $minAmountString));
        }
        $active = true;
        $fees = $this->safe_value_2($this->fees, $type, 'trading', array());
        $contractSize = null;
        if ($contract) {
            $contractSize = $this->safe_string($market, 'ctVal');
        }
        $leverage = $this->safe_number($market, 'lever', 1);
        return array_merge($fees, array(
            'id' => $id,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'settleId' => $settleCurrency,
            'settle' => $settle,
            'info' => $market,
            'type' => $type,
            'spot' => $spot,
            'futures' => $futures,
            'swap' => $swap,
            'contract' => $contract,
            'option' => $option,
            'linear' => $linear,
            'inverse' => $inverse,
            'active' => $active,
            'contractSize' => $contractSize,
            'precision' => $precision,
            'expiry' => $expiry,
            'expiryDatetime' => $this->iso8601($expiry),
            'limits' => array(
                'amount' => array(
                    'min' => $minAmount,
                    'max' => null,
                ),
                'price' => array(
                    'min' => $precision['price'],
                    'max' => null,
                ),
                'cost' => array(
                    'min' => $minCost,
                    'max' => null,
                ),
                'leverage' => array(
                    'max' => $leverage,
                ),
            ),
        ));
    }

    public function fetch_markets_by_type($type, $params = array ()) {
        $uppercaseType = strtoupper($type);
        $request = array(
            'instType' => $uppercaseType,
        );
        if ($uppercaseType === 'OPTION') {
            $defaultUnderlying = $this->safe_value($this->options, 'defaultUnderlying', 'BTC-USD');
            $currencyId = $this->safe_string_2($params, 'uly', 'marketId', $defaultUnderlying);
            if ($currencyId === null) {
                throw new ArgumentsRequired($this->id . ' fetchMarketsByType requires an underlying uly or marketId parameter for options markets');
            } else {
                $request['uly'] = $currencyId;
            }
        }
        $response = yield $this->publicGetPublicInstruments (array_merge($request, $params));
        //
        // spot, futures, swaps, options
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "alias":"", // this_week, next_week, quarter, next_quarter
        //                 "baseCcy":"BTC",
        //                 "category":"1",
        //                 "ctMult":"",
        //                 "ctType":"", // inverse, linear
        //                 "ctVal":"",
        //                 "ctValCcy":"",
        //                 "expTime":"",
        //                 "instId":"BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //                 "instType":"SPOT", // SPOT, FUTURES, SWAP, OPTION
        //                 "lever":"10",
        //                 "listTime":"1548133413000",
        //                 "lotSz":"0.00000001",
        //                 "minSz":"0.00001",
        //                 "optType":"",
        //                 "quoteCcy":"USDT",
        //                 "settleCcy":"",
        //                 "state":"live",
        //                 "stk":"",
        //                 "tickSz":"0.1",
        //                 "uly":""
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_markets($data);
    }

    public function safe_network($networkId) {
        $networksById = array(
            'Bitcoin' => 'BTC',
            'Omni' => 'OMNI',
            'TRON' => 'TRC20',
        );
        return $this->safe_string($networksById, $networkId, $networkId);
    }

    public function fetch_currencies($params = array ()) {
        // this endpoint requires authentication
        // while fetchCurrencies is a public API method by design
        // therefore we check the keys here
        // and fallback to generating the currencies from the markets
        if (!$this->check_required_credentials(false)) {
            return null;
        }
        // has['fetchCurrencies'] is currently set to false
        // it will reply with array("msg":"Request header “OK_ACCESS_KEY“ can't be empty.","code":"50103")
        // if you attempt to access it without authentication
        $response = yield $this->privateGetAssetCurrencies ($params);
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "canDep":true,
        //                 "canInternal":true,
        //                 "canWd":true,
        //                 "ccy":"USDT",
        //                 "chain":"USDT-ERC20",
        //                 "maxFee":"40",
        //                 "minFee":"20",
        //                 "minWd":"2",
        //                 "name":""
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        $dataByCurrencyId = $this->group_by($data, 'ccy');
        $currencyIds = is_array($dataByCurrencyId) ? array_keys($dataByCurrencyId) : array();
        $precision = $this->parse_number('0.00000001'); // default $precision, todo => fix "magic constants"
        for ($i = 0; $i < count($currencyIds); $i++) {
            $currencyId = $currencyIds[$i];
            $currency = $this->safe_currency($currencyId);
            $code = $currency['code'];
            $chains = $dataByCurrencyId[$currencyId];
            $networks = array();
            $currencyActive = false;
            for ($j = 0; $j < count($chains); $j++) {
                $chain = $chains[$j];
                $canDeposit = $this->safe_value($chain, 'canDep');
                $canWithdraw = $this->safe_value($chain, 'canWd');
                $canInternal = $this->safe_value($chain, 'canInternal');
                $active = ($canDeposit && $canWithdraw && $canInternal) ? true : false;
                $currencyActive = ($currencyActive === null) ? $active : $currencyActive;
                $networkId = $this->safe_string($chain, 'chain');
                if (mb_strpos($networkId, '-') !== false) {
                    $parts = explode('-', $networkId);
                    $chainPart = $this->safe_string($parts, 1, $networkId);
                    $network = $this->safe_network($chainPart);
                    $mainNet = $this->safe_value($chain, 'mainNet', false);
                    $layerTwo = $this->safe_value($this->options, 'layerTwo', array(
                        'Liquid' => true,
                        'Lightning' => true,
                    ));
                    if ($mainNet && !(is_array($layerTwo) && array_key_exists($chainPart, $layerTwo))) {
                        // BTC lighting and liquid are both mainnet but not the same as BTC-Bitcoin
                        $network = $code;
                    }
                    $networks[$network] = array(
                        'info' => $chain,
                        'id' => $networkId,
                        'network' => $network,
                        'active' => $active,
                        'fee' => $this->safe_number($chain, 'minFee'),
                        'precision' => null,
                        'limits' => array(
                            'withdraw' => array(
                                'min' => $this->safe_number($chain, 'minWd'),
                                'max' => null,
                            ),
                        ),
                    );
                }
            }
            $result[$code] = array(
                'info' => null,
                'code' => $code,
                'id' => $currencyId,
                'name' => null,
                'active' => $currencyActive,
                'fee' => null,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'networks' => $networks,
            );
        }
        return $result;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
        );
        $limit = ($limit === null) ? 20 : $limit;
        if ($limit !== null) {
            $request['sz'] = $limit; // max 400
        }
        $response = yield $this->publicGetMarketBooks (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             {
        //                 "asks":[
        //                     ["0.07228","4.211619","0","2"], // price, amount, liquidated orders, total open orders
        //                     ["0.0723","299.880364","0","2"],
        //                     ["0.07231","3.72832","0","1"],
        //                 ],
        //                 "bids":[
        //                     ["0.07221","18.5","0","1"],
        //                     ["0.0722","18.5","0","1"],
        //                     ["0.07219","0.505407","0","1"],
        //                 ],
        //                 "ts":"1621438475342"
        //             }
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0, array());
        $timestamp = $this->safe_integer($first, 'ts');
        return $this->parse_order_book($first, $symbol, $timestamp);
    }

    public function parse_ticker($ticker, $market = null) {
        //
        //     {
        //         "instType":"SPOT",
        //         "instId":"ETH-BTC",
        //         "last":"0.07319",
        //         "lastSz":"0.044378",
        //         "askPx":"0.07322",
        //         "askSz":"4.2",
        //         "bidPx":"0.0732",
        //         "bidSz":"6.050058",
        //         "open24h":"0.07801",
        //         "high24h":"0.07975",
        //         "low24h":"0.06019",
        //         "volCcy24h":"11788.887619",
        //         "vol24h":"167493.829229",
        //         "ts":"1621440583784",
        //         "sodUtc0":"0.07872",
        //         "sodUtc8":"0.07345"
        //     }
        //
        $timestamp = $this->safe_integer($ticker, 'ts');
        $marketId = $this->safe_string($ticker, 'instId');
        $market = $this->safe_market($marketId, $market, '-');
        $symbol = $market['symbol'];
        $last = $this->safe_number($ticker, 'last');
        $open = $this->safe_number($ticker, 'open24h');
        $quoteVolume = $this->safe_number($ticker, 'volCcy24h');
        $baseVolume = $this->safe_number($ticker, 'vol24h');
        $vwap = $this->vwap($baseVolume, $quoteVolume);
        return array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_number($ticker, 'high24h'),
            'low' => $this->safe_number($ticker, 'low24h'),
            'bid' => $this->safe_number($ticker, 'bidPx'),
            'bidVolume' => $this->safe_number($ticker, 'bidSz'),
            'ask' => $this->safe_number($ticker, 'askPx'),
            'askVolume' => $this->safe_number($ticker, 'askSz'),
            'vwap' => $vwap,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        );
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
        );
        $response = yield $this->publicGetMarketTicker (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":array(
        //             {
        //                 "instType":"SPOT",
        //                 "instId":"ETH-BTC",
        //                 "last":"0.07319",
        //                 "lastSz":"0.044378",
        //                 "askPx":"0.07322",
        //                 "askSz":"4.2",
        //                 "bidPx":"0.0732",
        //                 "bidSz":"6.050058",
        //                 "open24h":"0.07801",
        //                 "high24h":"0.07975",
        //                 "low24h":"0.06019",
        //                 "volCcy24h":"11788.887619",
        //                 "vol24h":"167493.829229",
        //                 "ts":"1621440583784",
        //                 "sodUtc0":"0.07872",
        //                 "sodUtc8":"0.07345"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0, array());
        return $this->parse_ticker($first, $market);
    }

    public function fetch_tickers_by_type($type, $symbols = null, $params = array ()) {
        yield $this->load_markets();
        $uppercaseType = strtoupper($type);
        $request = array(
            'instType' => strtoupper($type),
        );
        if ($uppercaseType === 'OPTION') {
            $defaultUnderlying = $this->safe_value($this->options, 'defaultUnderlying', 'BTC-USD');
            $currencyId = $this->safe_string_2($params, 'uly', 'marketId', $defaultUnderlying);
            if ($currencyId === null) {
                throw new ArgumentsRequired($this->id . ' fetchTickersByType requires an underlying uly or marketId parameter for options markets');
            } else {
                $request['uly'] = $currencyId;
            }
        }
        $response = yield $this->publicGetMarketTickers (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":array(
        //             array(
        //                 "instType":"SPOT",
        //                 "instId":"BCD-BTC",
        //                 "last":"0.0000769",
        //                 "lastSz":"5.4788",
        //                 "askPx":"0.0000777",
        //                 "askSz":"3.2197",
        //                 "bidPx":"0.0000757",
        //                 "bidSz":"4.7509",
        //                 "open24h":"0.0000885",
        //                 "high24h":"0.0000917",
        //                 "low24h":"0.0000596",
        //                 "volCcy24h":"9.2877",
        //                 "vol24h":"124824.1985",
        //                 "ts":"1621441741434",
        //                 "sodUtc0":"0.0000905",
        //                 "sodUtc8":"0.0000729"
        //             ),
        //         )
        //     }
        //
        $tickers = $this->safe_value($response, 'data', array());
        return $this->parse_tickers($tickers, $symbols);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $defaultType = $this->safe_string_2($this->options, 'fetchTickers', 'defaultType');
        $type = $this->safe_string($params, 'type', $defaultType);
        return yield $this->fetch_tickers_by_type($type, $symbols, $this->omit($params, 'type'));
    }

    public function parse_trade($trade, $market = null) {
        //
        // public fetchTrades
        //
        //     {
        //         "instId":"ETH-BTC",
        //         "side":"sell",
        //         "sz":"0.119501",
        //         "px":"0.07065",
        //         "tradeId":"15826757",
        //         "ts":"1621446178316"
        //     }
        //
        // private fetchMyTrades
        //
        //     {
        //         "side":"buy",
        //         "fillSz":"0.007533",
        //         "fillPx":"2654.98",
        //         "fee":"-0.000007533",
        //         "ordId":"317321390244397056",
        //         "instType":"SPOT",
        //         "instId":"ETH-USDT",
        //         "clOrdId":"",
        //         "posSide":"net",
        //         "billId":"317321390265368576",
        //         "tag":"0",
        //         "execType":"T",
        //         "tradeId":"107601752",
        //         "feeCcy":"ETH",
        //         "ts":"1621927314985"
        //     }
        //
        $id = $this->safe_string($trade, 'tradeId');
        $marketId = $this->safe_string($trade, 'instId');
        $market = $this->safe_market($marketId, $market, '-');
        $symbol = $market['symbol'];
        $timestamp = $this->safe_integer($trade, 'ts');
        $price = $this->safe_string_2($trade, 'fillPx', 'px');
        $amount = $this->safe_string_2($trade, 'fillSz', 'sz');
        $side = $this->safe_string($trade, 'side');
        $orderId = $this->safe_string($trade, 'ordId');
        $feeCostString = $this->safe_string($trade, 'fee');
        $fee = null;
        if ($feeCostString !== null) {
            $feeCostSigned = Precise::string_neg($feeCostString);
            $feeCurrencyId = $this->safe_string($trade, 'feeCcy');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCostSigned,
                'currency' => $feeCurrencyCode,
            );
        }
        $takerOrMaker = $this->safe_string($trade, 'execType');
        if ($takerOrMaker === 'T') {
            $takerOrMaker = 'taker';
        } else if ($takerOrMaker === 'M') {
            $takerOrMaker = 'maker';
        }
        return $this->safe_trade(array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $orderId,
            'type' => null,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => null,
            'fee' => $fee,
        ), $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100
        }
        $response = yield $this->publicGetMarketTrades (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":array(
        //             array("instId":"ETH-BTC","side":"sell","sz":"0.119501","px":"0.07065","tradeId":"15826757","ts":"1621446178316"),
        //             array("instId":"ETH-BTC","side":"sell","sz":"0.03","px":"0.07068","tradeId":"15826756","ts":"1621446178066"),
        //             array("instId":"ETH-BTC","side":"buy","sz":"0.507","px":"0.07069","tradeId":"15826755","ts":"1621446175085"),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        //     array(
        //         "1621447080000", // timestamp
        //         "0.07073", // open
        //         "0.07073", // high
        //         "0.07064", // low
        //         "0.07064", // close
        //         "12.08863", // base volume
        //         "0.854309" // quote volume
        //     )
        //
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, 2),
            $this->safe_number($ohlcv, 3),
            $this->safe_number($ohlcv, 4),
            $this->safe_number($ohlcv, 5),
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $price = $this->safe_string($params, 'price');
        $params = $this->omit($params, 'price');
        if ($limit === null) {
            $limit = 100; // default 100, max 100
        }
        $request = array(
            'instId' => $market['id'],
            'bar' => $this->timeframes[$timeframe],
            'limit' => $limit,
        );
        $defaultType = 'Candles';
        if ($since !== null) {
            $duration = $this->parse_timeframe($timeframe);
            $now = $this->milliseconds();
            $difference = $now - $since;
            // if the $since timestamp is more than $limit candles back in the past
            if ($difference > $limit * $duration * 1000) {
                $defaultType = 'HistoryCandles';
            }
            $durationInMilliseconds = $duration * 1000;
            $startTime = max ($since - 1, 0);
            $request['before'] = $startTime;
            $request['after'] = $this->sum($startTime, $durationInMilliseconds * $limit);
        }
        $options = $this->safe_value($this->options, 'fetchOHLCV', array());
        $defaultType = $this->safe_string($options, 'type', $defaultType); // Candles or HistoryCandles
        $type = $this->safe_string($params, 'type', $defaultType);
        $params = $this->omit($params, 'type');
        $method = 'publicGetMarket' . $type;
        if ($price === 'mark') {
            $method = 'publicGetMarketMarkPriceCandles';
        } else if ($price === 'index') {
            $method = 'publicGetMarketIndexCandles';
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             ["1621447080000","0.07073","0.07073","0.07064","0.07064","12.08863","0.854309"],
        //             ["1621447020000","0.0708","0.0709","0.0707","0.07072","58.517435","4.143309"],
        //             ["1621446960000","0.0707","0.07082","0.0707","0.07076","53.850841","3.810921"],
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
        );
        if ($since !== null) {
            $request['before'] = max ($since - 1, 0);
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->publicGetPublicFundingRateHistory (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":array(
        //             array(
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             ),
        //             {
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             }
        //         )
        //     }
        //
        $rates = array();
        $data = $this->safe_value($response, 'data');
        for ($i = 0; $i < count($data); $i++) {
            $rate = $data[$i];
            $timestamp = $this->safe_number($rate, 'fundingTime');
            $rates[] = array(
                'symbol' => $this->safe_symbol($this->safe_string($rate, 'instId')),
                'fundingRate' => $this->safe_number($rate, 'realizedRate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function fetch_index_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $request = array(
            'price' => 'index',
        );
        return yield $this->fetch_ohlcv($symbol, $timeframe, $since, $limit, array_merge($request, $params));
    }

    public function fetch_mark_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $request = array(
            'price' => 'mark',
        );
        return yield $this->fetch_ohlcv($symbol, $timeframe, $since, $limit, array_merge($request, $params));
    }

    public function parse_balance_by_type($type, $response) {
        if ($type === 'funding') {
            return $this->parse_funding_balance($response);
        } else {
            return $this->parse_trading_balance($response);
        }
    }

    public function parse_trading_balance($response) {
        $result = array( 'info' => $response );
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0, array());
        $timestamp = $this->safe_integer($first, 'uTime');
        $details = $this->safe_value($first, 'details', array());
        for ($i = 0; $i < count($details); $i++) {
            $balance = $details[$i];
            $currencyId = $this->safe_string($balance, 'ccy');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            // it may be incorrect to use total, free and used for swap accounts
            $eq = $this->safe_string($balance, 'eq');
            $availEq = $this->safe_string($balance, 'availEq');
            if ((strlen($eq) < 1) || (strlen($availEq) < 1)) {
                $account['free'] = $this->safe_string($balance, 'availBal');
                $account['used'] = $this->safe_string($balance, 'frozenBal');
            } else {
                $account['total'] = $eq;
                $account['free'] = $availEq;
            }
            $result[$code] = $account;
        }
        $result['timestamp'] = $timestamp;
        $result['datetime'] = $this->iso8601($timestamp);
        return $this->safe_balance($result);
    }

    public function parse_funding_balance($response) {
        $result = array( 'info' => $response );
        $data = $this->safe_value($response, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $balance = $data[$i];
            $currencyId = $this->safe_string($balance, 'ccy');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            // it may be incorrect to use total, free and used for swap accounts
            $account['total'] = $this->safe_string($balance, 'bal');
            $account['free'] = $this->safe_string($balance, 'availBal');
            $account['used'] = $this->safe_string($balance, 'frozenBal');
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function parse_trading_fee($fee, $market = null) {
        //
        //     {
        //         "category":"1",
        //         "delivery":"",
        //         "exercise":"",
        //         "instType":"SPOT",
        //         "level":"Lv1",
        //         "maker":"-0.0008",
        //         "taker":"-0.001",
        //         "ts":"1639043138472"
        //     }
        //
        return array(
            'info' => $fee,
            'symbol' => $this->safe_symbol(null, $market),
            'maker' => $this->safe_number($fee, 'maker'),
            'taker' => $this->safe_number($fee, 'taker'),
        );
    }

    public function fetch_trading_fee($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instType' => strtoupper($market['type']), // SPOT, MARGIN, SWAP, FUTURES, OPTION
            // 'instId' => $market['id'], // only applicable to SPOT/MARGIN
            // 'uly' => $market['id'], // only applicable to FUTURES/SWAP/OPTION
            // 'category' => '1', // 1 = Class A, 2 = Class B, 3 = Class C, 4 = Class D
        );
        if ($market['spot']) {
            $request['instId'] = $market['id'];
        } else if ($market['swap'] || $market['futures'] || $market['option']) {
            $request['uly'] = $market['baseId'] . '-' . $market['quoteId'];
        } else {
            throw new NotSupported($this->id . ' fetchTradingFee supports spot, swap, futures or option markets only');
        }
        $response = yield $this->privateGetAccountTradeFee (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "category":"1",
        //                 "delivery":"",
        //                 "exercise":"",
        //                 "instType":"SPOT",
        //                 "level":"Lv1",
        //                 "maker":"-0.0008",
        //                 "taker":"-0.001",
        //                 "ts":"1639043138472"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0, array());
        return $this->parse_trading_fee($first, $market);
    }

    public function fetch_balance($params = array ()) {
        yield $this->load_markets();
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $options = $this->safe_value($this->options, 'fetchBalance', array());
        $type = $this->safe_string($options, 'type', $defaultType);
        $type = $this->safe_string($params, 'type', $type);
        $params = $this->omit($params, 'type');
        $method = null;
        if ($type === 'funding') {
            $method = 'privateGetAssetBalances';
        } else {
            $method = 'privateGetAccountBalance';
        }
        $request = array(
            // 'ccy' => 'BTC,ETH', // comma-separated list of currency ids
        );
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "adjEq":"",
        //                 "details":array(
        //                     {
        //                         "availBal":"",
        //                         "availEq":"28.21006347",
        //                         "cashBal":"28.21006347",
        //                         "ccy":"USDT",
        //                         "crossLiab":"",
        //                         "disEq":"28.2687404020176",
        //                         "eq":"28.21006347",
        //                         "eqUsd":"28.2687404020176",
        //                         "frozenBal":"0",
        //                         "interest":"",
        //                         "isoEq":"0",
        //                         "isoLiab":"",
        //                         "liab":"",
        //                         "maxLoan":"",
        //                         "mgnRatio":"",
        //                         "notionalLever":"0",
        //                         "ordFrozen":"0",
        //                         "twap":"0",
        //                         "uTime":"1621556539861",
        //                         "upl":"0",
        //                         "uplLiab":""
        //                     }
        //                 ),
        //                 "imr":"",
        //                 "isoEq":"0",
        //                 "mgnRatio":"",
        //                 "mmr":"",
        //                 "notionalUsd":"",
        //                 "ordFroz":"",
        //                 "totalEq":"28.2687404020176",
        //                 "uTime":"1621556553510"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "adjEq":"",
        //                 "details":array(
        //                     {
        //                         "availBal":"0.049",
        //                         "availEq":"",
        //                         "cashBal":"0.049",
        //                         "ccy":"BTC",
        //                         "crossLiab":"",
        //                         "disEq":"1918.55678",
        //                         "eq":"0.049",
        //                         "eqUsd":"1918.55678",
        //                         "frozenBal":"0",
        //                         "interest":"",
        //                         "isoEq":"",
        //                         "isoLiab":"",
        //                         "liab":"",
        //                         "maxLoan":"",
        //                         "mgnRatio":"",
        //                         "notionalLever":"",
        //                         "ordFrozen":"0",
        //                         "twap":"0",
        //                         "uTime":"1621973128591",
        //                         "upl":"",
        //                         "uplLiab":""
        //                     }
        //                 ),
        //                 "imr":"",
        //                 "isoEq":"",
        //                 "mgnRatio":"",
        //                 "mmr":"",
        //                 "notionalUsd":"",
        //                 "ordFroz":"",
        //                 "totalEq":"1918.55678",
        //                 "uTime":"1622045126908"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        // funding
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "availBal":"0.00005426",
        //                 "bal":0.0000542600000000,
        //                 "ccy":"BTC",
        //                 "frozenBal":"0"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        return $this->parse_balance_by_type($type, $response);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            //
            //     Simple:
            //     - SPOT and OPTION buyer => cash
            //
            //     Single-currency margin:
            //     - Isolated MARGIN => isolated
            //     - Cross MARGIN => cross
            //     - Cross SPOT => cash
            //     - Cross FUTURES/SWAP/OPTION => cross
            //     - Isolated FUTURES/SWAP/OPTION => isolated
            //
            //     Multi-currency margin:
            //     - Isolated MARGIN => isolated
            //     - Cross SPOT => cross
            //     - Cross FUTURES/SWAP/OPTION => cross
            //     - Isolated FUTURES/SWAP/OPTION => isolated
            //
            // 'ccy' => currency['id'], // only applicable to cross MARGIN orders in single-currency margin
            // 'clOrdId' => $clientOrderId, // up to 32 characters, must be unique
            // 'tag' => tag, // up to 8 characters
            //
            //     In long/short mode, $side and posSide need to be combined
            //
            //     buy with long means open long
            //     sell with long means close long
            //     sell with short means open short
            //     buy with short means close short
            //
            'side' => $side,
            // 'posSide' => 'long', // long, short, // required in the long/short mode, and can only be long or short
            'ordType' => $type, // $market, limit, post_only, fok, ioc
            //
            //     for SPOT/MARGIN bought and sold at a limit $price, sz refers to the $amount of trading currency
            //     for SPOT/MARGIN bought at a $market $price, sz refers to the $amount of quoted currency
            //     for SPOT/MARGIN sold at a $market $price, sz refers to the $amount of trading currency
            //     for FUTURES/SWAP/OPTION buying and selling, sz refers to the number of contracts
            //
            // 'sz' => $this->amount_to_precision($symbol, $amount),
            // 'px' => $this->price_to_precision($symbol, $price), // limit orders only
            // 'reduceOnly' => false, // MARGIN orders only
        );
        $tdMode = $this->safe_string_lower($params, 'tdMode');
        if ($market['spot']) {
            $request['tdMode'] = 'cash';
        } else if ($market['contract']) {
            if ($tdMode === null) {
                throw new ArgumentsRequired($this->id . ' $params["tdMode"] is required to be either "isolated" or "cross"');
            } else if (($tdMode !== 'isolated') && ($tdMode !== 'cross')) {
                throw new BadRequest($this->id . ' $params["tdMode"] must be either "isolated" or "cross"');
            }
        }
        $postOnly = $this->safe_value($params, 'postOnly', false);
        if ($postOnly) {
            $request['ordType'] = 'post_only';
            $params = $this->omit($params, array( 'postOnly' ));
        }
        $clientOrderId = $this->safe_string_2($params, 'clOrdId', 'clientOrderId');
        if ($clientOrderId === null) {
            $brokerId = $this->safe_string($this->options, 'brokerId');
            if ($brokerId !== null) {
                $request['clOrdId'] = $brokerId . $this->uuid16();
            }
        } else {
            $request['clOrdId'] = $clientOrderId;
            $params = $this->omit($params, array( 'clOrdId', 'clientOrderId' ));
        }
        $request['sz'] = $this->amount_to_precision($symbol, $amount);
        if ($type === 'market') {
            if ($market['type'] === 'spot' && $side === 'buy') {
                // spot $market buy => "sz" can refer either to base currency units or to quote currency units
                // see documentation => https://www.okex.com/docs-v5/en/#rest-api-trade-place-$order
                $defaultTgtCcy = $this->safe_string($this->options, 'tgtCcy', 'base_ccy');
                $tgtCcy = $this->safe_string($params, 'tgtCcy', $defaultTgtCcy);
                if ($tgtCcy === 'quote_ccy') {
                    // quote_ccy => sz refers to units of quote currency
                    $request['tgtCcy'] = 'quote_ccy';
                    $notional = $this->safe_number($params, 'sz');
                    $createMarketBuyOrderRequiresPrice = $this->safe_value($this->options, 'createMarketBuyOrderRequiresPrice', true);
                    if ($createMarketBuyOrderRequiresPrice) {
                        if ($price !== null) {
                            if ($notional === null) {
                                $notional = $amount * $price;
                            }
                        } else if ($notional === null) {
                            throw new InvalidOrder($this->id . " createOrder() requires the $price argument with $market buy orders to calculate total $order cost ($amount to spend), where cost = $amount * $price-> Supply a $price argument to createOrder() call if you want the cost to be calculated for you from $price and $amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'sz' extra parameter (the exchange-specific behaviour)");
                        }
                    } else {
                        $notional = ($notional === null) ? $amount : $notional;
                    }
                    $precision = $market['precision']['price'];
                    $request['sz'] = $this->decimal_to_precision($notional, TRUNCATE, $precision, $this->precisionMode);
                } else {
                    // base_ccy => sz refers to units of base currency
                    $request['tgtCcy'] = 'base_ccy';
                }
                $params = $this->omit($params, array( 'tgtCcy' ));
            }
        } else {
            // non-$market orders
            $request['px'] = $this->price_to_precision($symbol, $price);
        }
        $extendedRequest = null;
        $defaultMethod = $this->safe_string($this->options, 'createOrder', 'privatePostTradeBatchOrders'); // or privatePostTradeOrder
        if ($defaultMethod === 'privatePostTradeOrder') {
            $extendedRequest = array_merge($request, $params);
        } else if ($defaultMethod === 'privatePostTradeBatchOrders') {
            // keep the $request body the same
            // submit a single $order in an array to the batch $order endpoint
            // because it has a lower ratelimit
            $extendedRequest = array( array_merge($request, $params) );
        } else {
            throw new ExchangeError($this->id . ' $this->options["createOrder"] must be either privatePostTradeBatchOrders or privatePostTradeOrder');
        }
        $response = yield $this->$defaultMethod ($extendedRequest);
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "clOrdId" => "oktswap6",
        //                 "ordId" => "312269865356374016",
        //                 "tag" => "",
        //                 "sCode" => "0",
        //                 "sMsg" => ""
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $first = $this->safe_value($data, 0);
        $order = $this->parse_order($first, $market);
        return array_merge($order, array(
            'type' => $type,
            'side' => $side,
        ));
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' cancelOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            // 'ordId' => $id, // either ordId or clOrdId is required
            // 'clOrdId' => $clientOrderId,
        );
        $clientOrderId = $this->safe_string_2($params, 'clOrdId', 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['clOrdId'] = $clientOrderId;
        } else {
            $request['ordId'] = $id;
        }
        $query = $this->omit($params, array( 'clOrdId', 'clientOrderId' ));
        $response = yield $this->privatePostTradeCancelOrder (array_merge($request, $query));
        // array("code":"0","data":[array("clOrdId":"","ordId":"317251910906576896","sCode":"0","sMsg":"")],"msg":"")
        $data = $this->safe_value($response, 'data', array());
        $order = $this->safe_value($data, 0);
        return $this->parse_order($order, $market);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'canceled' => 'canceled',
            'live' => 'open',
            'partially_filled' => 'open',
            'filled' => 'closed',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder
        //
        //     {
        //         "clOrdId" => "oktswap6",
        //         "ordId" => "312269865356374016",
        //         "tag" => "",
        //         "sCode" => "0",
        //         "sMsg" => ""
        //     }
        //
        // fetchOrder, fetchOpenOrders
        //
        //     {
        //         "accFillSz":"0",
        //         "avgPx":"",
        //         "cTime":"1621910749815",
        //         "category":"normal",
        //         "ccy":"",
        //         "clOrdId":"",
        //         "fee":"0",
        //         "feeCcy":"ETH",
        //         "fillPx":"",
        //         "fillSz":"0",
        //         "fillTime":"",
        //         "instId":"ETH-USDT",
        //         "instType":"SPOT",
        //         "lever":"",
        //         "ordId":"317251910906576896",
        //         "ordType":"limit",
        //         "pnl":"0",
        //         "posSide":"net",
        //         "px":"2000",
        //         "rebate":"0",
        //         "rebateCcy":"USDT",
        //         "side":"buy",
        //         "slOrdPx":"",
        //         "slTriggerPx":"",
        //         "state":"live",
        //         "sz":"0.001",
        //         "tag":"",
        //         "tdMode":"cash",
        //         "tpOrdPx":"",
        //         "tpTriggerPx":"",
        //         "tradeId":"",
        //         "uTime":"1621910749815"
        //     }
        //
        $id = $this->safe_string($order, 'ordId');
        $timestamp = $this->safe_integer($order, 'cTime');
        $lastTradeTimestamp = $this->safe_integer($order, 'fillTime');
        $side = $this->safe_string($order, 'side');
        $type = $this->safe_string($order, 'ordType');
        $postOnly = null;
        $timeInForce = null;
        if ($type === 'post_only') {
            $postOnly = true;
            $type = 'limit';
        } else if ($type === 'fok') {
            $timeInForce = 'FOK';
            $type = 'limit';
        } else if ($type === 'ioc') {
            $timeInForce = 'IOC';
            $type = 'limit';
        }
        $marketId = $this->safe_string($order, 'instId');
        $symbol = $this->safe_symbol($marketId, $market, '-');
        $filled = $this->safe_string($order, 'accFillSz');
        $price = $this->safe_string_2($order, 'px', 'slOrdPx');
        $average = $this->safe_string($order, 'avgPx');
        $status = $this->parse_order_status($this->safe_string($order, 'state'));
        $feeCostString = $this->safe_string($order, 'fee');
        $amount = null;
        $cost = null;
        // spot $market buy => "sz" can refer either to base currency units or to quote currency units
        // see documentation => https://www.okex.com/docs-v5/en/#rest-api-trade-place-$order
        $defaultTgtCcy = $this->safe_string($this->options, 'tgtCcy', 'base_ccy');
        $tgtCcy = $this->safe_string($order, 'tgtCcy', $defaultTgtCcy);
        $instType = $this->safe_string($order, 'instType');
        if (($side === 'buy') && ($type === 'market') && ($instType === 'SPOT') && ($tgtCcy === 'quote_ccy')) {
            // "sz" refers to the $cost
            $cost = $this->safe_string($order, 'sz');
        } else {
            // "sz" refers to the trade currency $amount
            $amount = $this->safe_string($order, 'sz');
        }
        $fee = null;
        if ($feeCostString !== null) {
            $feeCostSigned = Precise::string_neg($feeCostString);
            $feeCurrencyId = $this->safe_string($order, 'feeCcy');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $this->parse_number($feeCostSigned),
                'currency' => $feeCurrencyCode,
            );
        }
        $clientOrderId = $this->safe_string($order, 'clOrdId');
        if (($clientOrderId !== null) && (strlen($clientOrderId) < 1)) {
            $clientOrderId = null; // fix empty $clientOrderId string
        }
        $stopPrice = $this->safe_number($order, 'slTriggerPx');
        return $this->safe_order(array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'symbol' => $symbol,
            'type' => $type,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'side' => $side,
            'price' => $price,
            'stopPrice' => $stopPrice,
            'average' => $average,
            'cost' => $cost,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'status' => $status,
            'fee' => $fee,
            'trades' => null,
        ), $market);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrder() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            // 'clOrdId' => 'abcdef12345', // optional, [a-z0-9]array(1,32)
            // 'ordId' => $id,
        );
        $clientOrderId = $this->safe_string_2($params, 'clOrdId', 'clientOrderId');
        if ($clientOrderId !== null) {
            $request['clOrdId'] = $clientOrderId;
        } else {
            $request['ordId'] = $id;
        }
        $query = $this->omit($params, array( 'clOrdId', 'clientOrderId' ));
        $response = yield $this->privateGetTradeOrder (array_merge($request, $query));
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "accFillSz":"0",
        //                 "avgPx":"",
        //                 "cTime":"1621910749815",
        //                 "category":"normal",
        //                 "ccy":"",
        //                 "clOrdId":"",
        //                 "fee":"0",
        //                 "feeCcy":"ETH",
        //                 "fillPx":"",
        //                 "fillSz":"0",
        //                 "fillTime":"",
        //                 "instId":"ETH-USDT",
        //                 "instType":"SPOT",
        //                 "lever":"",
        //                 "ordId":"317251910906576896",
        //                 "ordType":"limit",
        //                 "pnl":"0",
        //                 "posSide":"net",
        //                 "px":"2000",
        //                 "rebate":"0",
        //                 "rebateCcy":"USDT",
        //                 "side":"buy",
        //                 "slOrdPx":"",
        //                 "slTriggerPx":"",
        //                 "state":"live",
        //                 "sz":"0.001",
        //                 "tag":"",
        //                 "tdMode":"cash",
        //                 "tpOrdPx":"",
        //                 "tpTriggerPx":"",
        //                 "tradeId":"",
        //                 "uTime":"1621910749815"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $order = $this->safe_value($data, 0);
        return $this->parse_order($order, $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'instType' => 'SPOT', // SPOT, MARGIN, SWAP, FUTURES, OPTION
            // 'uly' => currency['id'],
            // 'instId' => $market['id'],
            // 'ordType' => 'limit', // $market, $limit, post_only, fok, ioc, comma-separated
            // 'state' => 'live', // live, partially_filled
            // 'after' => orderId,
            // 'before' => orderId,
            // 'limit' => $limit, // default 100, max 100
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['instId'] = $market['id'];
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $response = yield $this->privateGetTradeOrdersPending (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "accFillSz":"0",
        //                 "avgPx":"",
        //                 "cTime":"1621910749815",
        //                 "category":"normal",
        //                 "ccy":"",
        //                 "clOrdId":"",
        //                 "fee":"0",
        //                 "feeCcy":"ETH",
        //                 "fillPx":"",
        //                 "fillSz":"0",
        //                 "fillTime":"",
        //                 "instId":"ETH-USDT",
        //                 "instType":"SPOT",
        //                 "lever":"",
        //                 "ordId":"317251910906576896",
        //                 "ordType":"limit",
        //                 "pnl":"0",
        //                 "posSide":"net",
        //                 "px":"2000",
        //                 "rebate":"0",
        //                 "rebateCcy":"USDT",
        //                 "side":"buy",
        //                 "slOrdPx":"",
        //                 "slTriggerPx":"",
        //                 "state":"live",
        //                 "sz":"0.001",
        //                 "tag":"",
        //                 "tdMode":"cash",
        //                 "tpOrdPx":"",
        //                 "tpTriggerPx":"",
        //                 "tradeId":"",
        //                 "uTime":"1621910749815"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $options = $this->safe_value($this->options, 'fetchClosedOrders', array());
        $type = $this->safe_string($options, 'type', $defaultType);
        $type = $this->safe_string($params, 'type', $type);
        $params = $this->omit($params, 'type');
        $request = array(
            // 'instType' => strtoupper($type), // SPOT, MARGIN, SWAP, FUTURES, OPTION
            // 'uly' => currency['id'],
            // 'instId' => $market['id'],
            // 'ordType' => 'limit', // $market, $limit, post_only, fok, ioc, comma-separated
            // 'state' => 'filled', // filled, canceled
            // 'after' => orderId,
            // 'before' => orderId,
            // 'limit' => $limit, // default 100, max 100
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            if ($market['futures'] || $market['swap']) {
                $type = $market['type'];
            }
            $request['instId'] = $market['id'];
        }
        $request['instType'] = strtoupper($type);
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $method = $this->safe_string($options, 'method', 'privateGetTradeOrdersHistory');
        $response = yield $this->$method (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "accFillSz":"0",
        //                 "avgPx":"",
        //                 "cTime":"1621910749815",
        //                 "category":"normal",
        //                 "ccy":"",
        //                 "clOrdId":"",
        //                 "fee":"0",
        //                 "feeCcy":"ETH",
        //                 "fillPx":"",
        //                 "fillSz":"0",
        //                 "fillTime":"",
        //                 "instId":"ETH-USDT",
        //                 "instType":"SPOT",
        //                 "lever":"",
        //                 "ordId":"317251910906576896",
        //                 "ordType":"limit",
        //                 "pnl":"0",
        //                 "posSide":"net",
        //                 "px":"2000",
        //                 "rebate":"0",
        //                 "rebateCcy":"USDT",
        //                 "side":"buy",
        //                 "slOrdPx":"",
        //                 "slTriggerPx":"",
        //                 "state":"live",
        //                 "sz":"0.001",
        //                 "tag":"",
        //                 "tdMode":"cash",
        //                 "tpOrdPx":"",
        //                 "tpTriggerPx":"",
        //                 "tradeId":"",
        //                 "uTime":"1621910749815"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $defaultType = $this->safe_string($this->options, 'defaultType');
        $options = $this->safe_value($this->options, 'fetchMyTrades', array());
        $type = $this->safe_string($options, 'type', $defaultType);
        $params = $this->omit($params, 'type');
        yield $this->load_markets();
        $request = array(
            // 'instType' => 'SPOT', // SPOT, MARGIN, SWAP, FUTURES, OPTION
            // 'uly' => currency['id'],
            // 'instId' => $market['id'],
            // 'ordId' => orderId,
            // 'after' => billId,
            // 'before' => billId,
            // 'limit' => $limit, // default 100, max 100
        );
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
            $request['instId'] = $market['id'];
            $type = $market['type'];
        }
        $request['instType'] = strtoupper($type);
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $response = yield $this->privateGetTradeFillsHistory (array_merge($request, $params));
        //
        //     {
        //         "code":"0",
        //         "data":array(
        //             {
        //                 "side":"buy",
        //                 "fillSz":"0.007533",
        //                 "fillPx":"2654.98",
        //                 "fee":"-0.000007533",
        //                 "ordId":"317321390244397056",
        //                 "instType":"SPOT",
        //                 "instId":"ETH-USDT",
        //                 "clOrdId":"",
        //                 "posSide":"net",
        //                 "billId":"317321390265368576",
        //                 "tag":"0",
        //                 "execType":"T",
        //                 "tradeId":"107601752",
        //                 "feeCcy":"ETH",
        //                 "ts":"1621927314985"
        //             }
        //         ),
        //         "msg":""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit, $params);
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            // 'instrument_id' => market['id'],
            'ordId' => $id,
            // 'after' => '1', // return the page after the specified page number
            // 'before' => '1', // return the page before the specified page number
            // 'limit' => $limit, // optional, number of results per $request, default = maximum = 100
        );
        return yield $this->fetch_my_trades($symbol, $since, $limit, array_merge($request, $params));
    }

    public function fetch_ledger($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $options = $this->safe_value($this->options, 'fetchLedger', array());
        $method = $this->safe_string($options, 'method');
        $method = $this->safe_string($params, 'method', $method);
        $params = $this->omit($params, 'method');
        $request = array(
            // 'instType' => null, // 'SPOT', 'MARGIN', 'SWAP', 'FUTURES", 'OPTION'
            // 'ccy' => null, // $currency['id'],
            // 'mgnMode' => null, // 'isolated', 'cross'
            // 'ctType' => null, // 'linear', 'inverse', only applicable to FUTURES/SWAP
            // 'type' => null,
            //     1 Transfer,
            //     2 Trade,
            //     3 Delivery,
            //     4 Auto token conversion,
            //     5 Liquidation,
            //     6 Margin transfer,
            //     7 Interest deduction,
            //     8 Funding rate,
            //     9 ADL,
            //     10 Clawback,
            //     11 System token conversion
            // 'subType' => null,
            //     1 Buy
            //     2 Sell
            //     3 Open long
            //     4 Open short
            //     5 Close long
            //     6 Close short
            //     9 Interest deduction
            //     11 Transfer in
            //     12 Transfer out
            //     160 Manual margin increase
            //     161 Manual margin decrease
            //     162 Auto margin increase
            //     110 Auto buy
            //     111 Auto sell
            //     118 System token conversion transfer in
            //     119 System token conversion transfer out
            //     100 Partial liquidation close long
            //     101 Partial liquidation close short
            //     102 Partial liquidation buy
            //     103 Partial liquidation sell
            //     104 Liquidation long
            //     105 Liquidation short
            //     106 Liquidation buy
            //     107 Liquidation sell
            //     110 Liquidation transfer in
            //     111 Liquidation transfer out
            //     125 ADL close long
            //     126 ADL close short
            //     127 ADL buy
            //     128 ADL sell
            //     170 Exercised
            //     171 Counterparty exercised
            //     172 Expired OTM
            //     112 Delivery long
            //     113 Delivery short
            //     117 Delivery/Exercise clawback
            //     173 Funding fee expense
            //     174 Funding fee income
            //
            // 'after' => 'id', // return records earlier than the requested bill id
            // 'before' => 'id', // return records newer than the requested bill id
            // 'limit' => 100, // default 100, max 100
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['ccy'] = $currency['id'];
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "bal" => "0.0000819307998198",
        //                 "balChg" => "-664.2679586599999802",
        //                 "billId" => "310394313544966151",
        //                 "ccy" => "USDT",
        //                 "fee" => "0",
        //                 "from" => "",
        //                 "instId" => "LTC-USDT",
        //                 "instType" => "SPOT",
        //                 "mgnMode" => "cross",
        //                 "notes" => "",
        //                 "ordId" => "310394313519800320",
        //                 "pnl" => "0",
        //                 "posBal" => "0",
        //                 "posBalChg" => "0",
        //                 "subType" => "2",
        //                 "sz" => "664.26795866",
        //                 "to" => "",
        //                 "ts" => "1620275771196",
        //                 "type" => "2"
        //             }
        //         )
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "billId" => "12344",
        //                 "ccy" => "BTC",
        //                 "balChg" => "2",
        //                 "bal" => "12",
        //                 "type" => "1",
        //                 "ts" => "1597026383085"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_ledger($data, $currency, $since, $limit);
    }

    public function parse_ledger_entry_type($type) {
        $types = array(
            '1' => 'transfer', // transfer
            '2' => 'trade', // trade
            '3' => 'trade', // delivery
            '4' => 'rebate', // auto token conversion
            '5' => 'trade', // liquidation
            '6' => 'transfer', // margin transfer
            '7' => 'trade', // interest deduction
            '8' => 'fee', // funding rate
            '9' => 'trade', // adl
            '10' => 'trade', // clawback
            '11' => 'trade', // system token conversion
        );
        return $this->safe_string($types, $type, $type);
    }

    public function parse_ledger_entry($item, $currency = null) {
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "bal" => "0.0000819307998198",
        //         "balChg" => "-664.2679586599999802",
        //         "billId" => "310394313544966151",
        //         "ccy" => "USDT",
        //         "fee" => "0",
        //         "from" => "",
        //         "instId" => "LTC-USDT",
        //         "instType" => "SPOT",
        //         "mgnMode" => "cross",
        //         "notes" => "",
        //         "ordId" => "310394313519800320",
        //         "pnl" => "0",
        //         "posBal" => "0",
        //         "posBalChg" => "0",
        //         "subType" => "2",
        //         "sz" => "664.26795866",
        //         "to" => "",
        //         "ts" => "1620275771196",
        //         "type" => "2"
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "billId" => "12344",
        //         "ccy" => "BTC",
        //         "balChg" => "2",
        //         "bal" => "12",
        //         "type" => "1",
        //         "ts" => "1597026383085"
        //     }
        //
        $id = $this->safe_string($item, 'billId');
        $account = null;
        $referenceId = $this->safe_string($item, 'ordId');
        $referenceAccount = null;
        $type = $this->parse_ledger_entry_type($this->safe_string($item, 'type'));
        $code = $this->safe_currency_code($this->safe_string($item, 'ccy'), $currency);
        $amountString = $this->safe_string($item, 'balChg');
        $amount = $this->parse_number($amountString);
        $timestamp = $this->safe_integer($item, 'ts');
        $feeCostString = $this->safe_string($item, 'fee');
        $fee = null;
        if ($feeCostString !== null) {
            $fee = array(
                'cost' => $this->parse_number(Precise::string_neg($feeCostString)),
                'currency' => $code,
            );
        }
        $before = null;
        $afterString = $this->safe_string($item, 'bal');
        $after = $this->parse_number($afterString);
        $status = 'ok';
        $marketId = $this->safe_string($item, 'instId');
        $symbol = null;
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
            $symbol = $market['symbol'];
        }
        return array(
            'id' => $id,
            'info' => $item,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'account' => $account,
            'referenceId' => $referenceId,
            'referenceAccount' => $referenceAccount,
            'type' => $type,
            'currency' => $code,
            'symbol' => $symbol,
            'amount' => $amount,
            'before' => $before, // balance $before
            'after' => $after, // balance $after
            'status' => $status,
            'fee' => $fee,
        );
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     {
        //         "addr" => "okbtothemoon",
        //         "memo" => "971668", // may be missing
        //         "tag":"52055", // may be missing
        //         "pmtId" => "", // may be missing
        //         "ccy" => "BTC",
        //         "to" => "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //         "selected" => true
        //     }
        //
        //     {
        //         "ccy":"usdt-erc20",
        //         "to":"6",
        //         "addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa",
        //         "selected":true
        //     }
        //
        //     {
        //       "chain" => "ETH-OKExChain",
        //       "ctAddr" => "72315c",
        //       "ccy" => "ETH",
        //       "to" => "6",
        //       "addr" => "0x1c9f2244d1ccaa060bd536827c18925db10db102",
        //       "selected" => true
        //     }
        //
        $address = $this->safe_string($depositAddress, 'addr');
        $tag = $this->safe_string_2($depositAddress, 'tag', 'pmtId');
        $tag = $this->safe_string($depositAddress, 'memo', $tag);
        $currencyId = $this->safe_string($depositAddress, 'ccy');
        $currency = $this->safe_currency($currencyId, $currency);
        $code = $currency['code'];
        $chain = $this->safe_string($depositAddress, 'chain');
        $networks = $this->safe_value($currency, 'networks', array());
        $networksById = $this->index_by($networks, 'id');
        $networkData = $this->safe_value($networksById, $chain);
        $network = $this->safe_string($networkData, 'network');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => $tag,
            'network' => $network,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'ccy' => $currency['id'],
        );
        $response = yield $this->privateGetAssetDepositAddress (array_merge($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             array(
        //                 "addr" => "okbtothemoon",
        //                 "memo" => "971668", // may be missing
        //                 "tag":"52055", // may be missing
        //                 "pmtId" => "", // may be missing
        //                 "ccy" => "BTC",
        //                 "to" => "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //                 "selected" => true
        //             ),
        //             // array("ccy":"usdt-erc20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true),
        //             // array("ccy":"usdt-trc20","to":"6","addr":"TRrd5SiSZrfQVRKm4e9SRSbn2LNTYqCjqx","selected":true),
        //             // array("ccy":"usdt_okexchain","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true),
        //             // array("ccy":"usdt_kip20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $filtered = $this->filter_by($data, 'selected', true);
        $parsed = $this->parse_deposit_addresses($filtered, array( $code ), false);
        return $this->index_by($parsed, 'network');
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $rawNetwork = $this->safe_string_upper($params, 'network');
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string($networks, $rawNetwork, $rawNetwork);
        $params = $this->omit($params, 'network');
        $response = yield $this->fetch_deposit_addresses_by_network($code, $params);
        $result = null;
        if ($network === null) {
            $result = $this->safe_value($response, $code);
            if ($result === null) {
                $alias = $this->safe_string($networks, $code, $code);
                $result = $this->safe_value($response, $alias);
                if ($result === null) {
                    $defaultNetwork = $this->safe_string($this->options, 'defaultNetwork', 'ERC20');
                    $result = $this->safe_value($response, $defaultNetwork);
                    if ($result === null) {
                        $values = is_array($response) ? array_values($response) : array();
                        $result = $this->safe_value($values, 0);
                        if ($result === null) {
                            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find deposit address for ' . $code);
                        }
                    }
                }
            }
            return $result;
        }
        $result = $this->safe_value($response, $network);
        if ($result === null) {
            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find ' . $network . ' deposit address for ' . $code);
        }
        return $result;
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $this->check_address($address);
        yield $this->load_markets();
        $currency = $this->currency($code);
        if ($tag !== null) {
            $address = $address . ':' . $tag;
        }
        $fee = $this->safe_string($params, 'fee');
        if ($fee === null) {
            throw new ArgumentsRequired($this->id . " withdraw() requires a 'fee' string parameter, $network $transaction $fee must be ≥ 0. Withdrawals to OKCoin or OKEx are $fee-free, please set '0'. Withdrawing to external digital asset $address requires $network $transaction $fee->");
        }
        $request = array(
            'ccy' => $currency['id'],
            'toAddr' => $address,
            'dest' => '4', // 2 = OKCoin International, 3 = OKEx 4 = others
            'amt' => $this->number_to_string($amount),
            'fee' => $this->number_to_string($fee), // withdrawals to OKCoin or OKEx are $fee-free, please set 0
        );
        if (is_array($params) && array_key_exists('password', $params)) {
            $request['pwd'] = $params['password'];
        } else if (is_array($params) && array_key_exists('pwd', $params)) {
            $request['pwd'] = $params['pwd'];
        }
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_upper($params, 'network'); // this line allows the user to specify either ERC20 or ETH
        $network = $this->safe_string($networks, $network, $network); // handle ETH>ERC20 alias
        if ($network !== null) {
            $request['chain'] = $currency['id'] . '-' . $network;
            $params = $this->omit($params, 'network');
        }
        $query = $this->omit($params, array( 'fee', 'password', 'pwd' ));
        if (!(is_array($request) && array_key_exists('pwd', $request))) {
            throw new ExchangeError($this->id . ' withdraw() requires a password parameter or a pwd parameter, it must be the funding password, not the API passphrase');
        }
        $response = yield $this->privatePostAssetWithdrawal (array_merge($request, $query));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "amt" => "0.1",
        //                 "wdId" => "67485",
        //                 "ccy" => "BTC"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $transaction = $this->safe_value($data, 0);
        return $this->parse_transaction($transaction, $currency);
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'ccy' => $currency['id'],
            // 'state' => 2, // 0 waiting for confirmation, 1 deposit credited, 2 deposit successful
            // 'after' => $since,
            // 'before' $this->milliseconds(),
            // 'limit' => $limit, // default 100, max 100
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['ccy'] = $currency['id'];
        }
        if ($since !== null) {
            $request['before'] = max ($since - 1, 0);
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $response = yield $this->privateGetAssetDepositHistory (array_merge($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             array(
        //                 "amt" => "0.01044408",
        //                 "txId" => "1915737_3_0_0_asset",
        //                 "ccy" => "BTC",
        //                 "from" => "13801825426",
        //                 "to" => "",
        //                 "ts" => "1597026383085",
        //                 "state" => "2",
        //                 "depId" => "4703879"
        //             ),
        //             array(
        //                 "amt" => "491.6784211",
        //                 "txId" => "1744594_3_184_0_asset",
        //                 "ccy" => "OKB",
        //                 "from" => "",
        //                 "to" => "",
        //                 "ts" => "1597026383085",
        //                 "state" => "2",
        //                 "depId" => "4703809"
        //             ),
        //             {
        //                 "amt" => "223.18782496",
        //                 "txId" => "6d892c669225b1092c780bf0da0c6f912fc7dc8f6b8cc53b003288624c",
        //                 "ccy" => "USDT",
        //                 "from" => "",
        //                 "to" => "39kK4XvgEuM7rX9frgyHoZkWqx4iKu1spD",
        //                 "ts" => "1597026383085",
        //                 "state" => "2",
        //                 "depId" => "4703779"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transactions($data, $currency, $since, $limit, $params);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'ccy' => $currency['id'],
            // 'state' => 2, // -3 => pending cancel, -2 canceled, -1 failed, 0, pending, 1 sending, 2 sent, 3 awaiting email verification, 4 awaiting manual verification, 5 awaiting identity verification
            // 'after' => $since,
            // 'before' => $this->milliseconds(),
            // 'limit' => $limit, // default 100, max 100
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['ccy'] = $currency['id'];
        }
        if ($since !== null) {
            $request['before'] = max ($since - 1, 0);
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $response = yield $this->privateGetAssetWithdrawalHistory (array_merge($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             array(
        //                 "amt" => "0.094",
        //                 "wdId" => "4703879",
        //                 "fee" => "0.01000000eth",
        //                 "txId" => "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //                 "ccy" => "ETH",
        //                 "from" => "13426335357",
        //                 "to" => "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //                 "ts" => "1597026383085",
        //                 "state" => "2"
        //             ),
        //             {
        //                 "amt" => "0.01",
        //                 "wdId" => "4703879",
        //                 "fee" => "0.00000000btc",
        //                 "txId" => "",
        //                 "ccy" => "BTC",
        //                 "from" => "13426335357",
        //                 "to" => "13426335357",
        //                 "ts" => "1597026383085",
        //                 "state" => "2"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transactions($data, $currency, $since, $limit, $params);
    }

    public function parse_transaction_status($status) {
        //
        // deposit $statuses
        //
        //     {
        //         '0' => 'waiting for confirmation',
        //         '1' => 'deposit credited',
        //         '2' => 'deposit successful'
        //     }
        //
        // withdrawal $statuses
        //
        //     {
        //        '-3' => 'pending cancel',
        //        '-2' => 'canceled',
        //        '-1' => 'failed',
        //         '0' => 'pending',
        //         '1' => 'sending',
        //         '2' => 'sent',
        //         '3' => 'awaiting email verification',
        //         '4' => 'awaiting manual verification',
        //         '5' => 'awaiting identity verification'
        //     }
        //
        $statuses = array(
            '-3' => 'pending',
            '-2' => 'canceled',
            '-1' => 'failed',
            '0' => 'pending',
            '1' => 'pending',
            '2' => 'ok',
            '3' => 'pending',
            '4' => 'pending',
            '5' => 'pending',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // withdraw
        //
        //     {
        //         "amt" => "0.1",
        //         "wdId" => "67485",
        //         "ccy" => "BTC"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amt" => "0.094",
        //         "wdId" => "4703879",
        //         "fee" => "0.01000000eth",
        //         "txId" => "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //         "ccy" => "ETH",
        //         "from" => "13426335357",
        //         "to" => "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //         'tag' => string,
        //         'pmtId' => string,
        //         'memo' => string,
        //         "ts" => "1597026383085",
        //         "state" => "2"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "amt" => "0.01044408",
        //         "txId" => "1915737_3_0_0_asset",
        //         "ccy" => "BTC",
        //         "from" => "13801825426",
        //         "to" => "",
        //         "ts" => "1597026383085",
        //         "state" => "2",
        //         "depId" => "4703879"
        //     }
        //
        $type = null;
        $id = null;
        $withdrawalId = $this->safe_string($transaction, 'wdId');
        $addressFrom = $this->safe_string($transaction, 'from');
        $addressTo = $this->safe_string($transaction, 'to');
        $address = $addressTo;
        $tagTo = $this->safe_string_2($transaction, 'tag', 'memo');
        $tagTo = $this->safe_string_2($transaction, 'pmtId', $tagTo);
        if ($withdrawalId !== null) {
            $type = 'withdrawal';
            $id = $withdrawalId;
        } else {
            // the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            $id = $this->safe_string($transaction, 'depId');
            $type = 'deposit';
        }
        $currencyId = $this->safe_string($transaction, 'ccy');
        $code = $this->safe_currency_code($currencyId);
        $amount = $this->safe_number($transaction, 'amt');
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'state'));
        $txid = $this->safe_string($transaction, 'txId');
        $timestamp = $this->safe_integer($transaction, 'ts');
        $feeCost = null;
        if ($type === 'deposit') {
            $feeCost = 0;
        } else {
            $feeCost = $this->safe_number($transaction, 'fee');
        }
        // todo parse tags
        return array(
            'info' => $transaction,
            'id' => $id,
            'currency' => $code,
            'amount' => $amount,
            'addressFrom' => $addressFrom,
            'addressTo' => $addressTo,
            'address' => $address,
            'tagFrom' => null,
            'tagTo' => $tagTo,
            'tag' => $tagTo,
            'status' => $status,
            'type' => $type,
            'updated' => null,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'fee' => array(
                'currency' => $code,
                'cost' => $feeCost,
            ),
        );
    }

    public function fetch_leverage($symbol, $params = array ()) {
        yield $this->load_markets();
        $marginMode = $this->safe_string_lower($params, 'mgnMode');
        $params = $this->omit($params, array( 'mgnMode' ));
        if (($marginMode !== 'cross') && ($marginMode !== 'isolated')) {
            throw new BadRequest($this->id . ' setLeverage $params["mgnMode"] must be either "cross" or "isolated"');
        }
        $market = $this->market($symbol);
        $request = array(
            'instId' => $market['id'],
            'mgnMode' => $marginMode,
        );
        $response = yield $this->privateGetAccountLeverageInfo (array_merge($request, $params));
        //
        //     {
        //       "code" => "0",
        //       "data" => array(
        //         {
        //           "instId" => "BTC-USDT-SWAP",
        //           "lever" => "5.00000000",
        //           "mgnMode" => "isolated",
        //           "posSide" => "net"
        //         }
        //       ),
        //       "msg" => ""
        //     }
        //
        return $response;
    }

    public function fetch_position($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $type = $this->safe_string($params, 'type');
        $params = $this->omit($params, 'type');
        $request = array(
            // instType String No Instrument $type, MARGIN, SWAP, FUTURES, OPTION
            'instId' => $market['id'],
            // posId String No Single $position ID or multiple $position IDs (no more than 20) separated with comma
        );
        if ($type !== null) {
            $request['instType'] = strtoupper($type);
        }
        $params = $this->omit($params, 'type');
        $response = yield $this->privateGetAccountPositions ($params);
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "adl":"1",
        //                 "availPos":"1",
        //                 "avgPx":"2566.31",
        //                 "cTime":"1619507758793",
        //                 "ccy":"ETH",
        //                 "deltaBS":"",
        //                 "deltaPA":"",
        //                 "gammaBS":"",
        //                 "gammaPA":"",
        //                 "imr":"",
        //                 "instId":"ETH-USD-210430",
        //                 "instType":"FUTURES",
        //                 "interest":"0",
        //                 "last":"2566.22",
        //                 "lever":"10",
        //                 "liab":"",
        //                 "liabCcy":"",
        //                 "liqPx":"2352.8496681818233",
        //                 "margin":"0.0003896645377994",
        //                 "mgnMode":"isolated",
        //                 "mgnRatio":"11.731726509588816",
        //                 "mmr":"0.0000311811092368",
        //                 "optVal":"",
        //                 "pTime":"1619507761462",
        //                 "pos":"1",
        //                 "posCcy":"",
        //                 "posId":"307173036051017730",
        //                 "posSide":"long",
        //                 "thetaBS":"",
        //                 "thetaPA":"",
        //                 "tradeId":"109844",
        //                 "uTime":"1619507761462",
        //                 "upl":"-0.0000009932766034",
        //                 "uplRatio":"-0.0025490556801078",
        //                 "vegaBS":"",
        //                 "vegaPA":""
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $position = $this->safe_value($data, 0);
        if ($position === null) {
            return $position;
        }
        return $this->parse_position($position);
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        yield $this->load_markets();
        // $defaultType = $this->safe_string_2($this->options, 'fetchPositions', 'defaultType');
        // $type = $this->safe_string($params, 'type', $defaultType);
        $type = $this->safe_string($params, 'type');
        $params = $this->omit($params, 'type');
        $request = array(
            // instType String No Instrument $type, MARGIN, SWAP, FUTURES, OPTION, instId will be checked against instType when both parameters are passed, and the position information of the instId will be returned.
            // instId String No Instrument ID, e.g. BTC-USD-190927-5000-C
            // posId String No Single position ID or multiple position IDs (no more than 20) separated with comma
        );
        if ($type !== null) {
            $request['instType'] = strtoupper($type);
        }
        $params = $this->omit($params, 'type');
        $response = yield $this->privateGetAccountPositions (array_merge($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "adl":"1",
        //                 "availPos":"1",
        //                 "avgPx":"2566.31",
        //                 "cTime":"1619507758793",
        //                 "ccy":"ETH",
        //                 "deltaBS":"",
        //                 "deltaPA":"",
        //                 "gammaBS":"",
        //                 "gammaPA":"",
        //                 "imr":"",
        //                 "instId":"ETH-USD-210430",
        //                 "instType":"FUTURES",
        //                 "interest":"0",
        //                 "last":"2566.22",
        //                 "lever":"10",
        //                 "liab":"",
        //                 "liabCcy":"",
        //                 "liqPx":"2352.8496681818233",
        //                 "margin":"0.0003896645377994",
        //                 "mgnMode":"isolated",
        //                 "mgnRatio":"11.731726509588816",
        //                 "mmr":"0.0000311811092368",
        //                 "optVal":"",
        //                 "pTime":"1619507761462",
        //                 "pos":"1",
        //                 "posCcy":"",
        //                 "posId":"307173036051017730",
        //                 "posSide":"long",
        //                 "thetaBS":"",
        //                 "thetaPA":"",
        //                 "tradeId":"109844",
        //                 "uTime":"1619507761462",
        //                 "upl":"-0.0000009932766034",
        //                 "uplRatio":"-0.0025490556801078",
        //                 "vegaBS":"",
        //                 "vegaPA":""
        //             }
        //         )
        //     }
        //
        $positions = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($positions); $i++) {
            $entry = $positions[$i];
            $instrument = $this->safe_string($entry, 'instType');
            if (($instrument === 'FUTURES') || $instrument === ('SWAP')) {
                $result[] = $this->parse_position($positions[$i]);
            }
        }
        return $result;
    }

    public function parse_position($position, $market = null) {
        //
        //     {
        //       "adl" => "3",
        //       "availPos" => "1",
        //       "avgPx" => "34131.1",
        //       "cTime" => "1627227626502",
        //       "ccy" => "USDT",
        //       "deltaBS" => "",
        //       "deltaPA" => "",
        //       "gammaBS" => "",
        //       "gammaPA" => "",
        //       "imr" => "170.66093041794787",
        //       "instId" => "BTC-USDT-SWAP",
        //       "instType" => "SWAP",
        //       "interest" => "0",
        //       "last" => "34134.4",
        //       "lever" => "2",
        //       "liab" => "",
        //       "liabCcy" => "",
        //       "liqPx" => "12608.959083877446",
        //       "markPx" => "4786.459271773621",
        //       "margin" => "",
        //       "mgnMode" => "cross",
        //       "mgnRatio" => "140.49930117599155",
        //       "mmr" => "1.3652874433435829",
        //       "notionalUsd" => "341.5130010779638",
        //       "optVal" => "",
        //       "pos" => "1",
        //       "posCcy" => "",
        //       "posId" => "339552508062380036",
        //       "posSide" => "long",
        //       "thetaBS" => "",
        //       "thetaPA" => "",
        //       "tradeId" => "98617799",
        //       "uTime" => "1627227626502",
        //       "upl" => "0.0108608358957281",
        //       "uplRatio" => "0.0000636418743944",
        //       "vegaBS" => "",
        //       "vegaPA" => ""
        //     }
        //
        $marketId = $this->safe_string($position, 'instId');
        $market = $this->safe_market($marketId, $market);
        $symbol = $market['symbol'];
        $contractsString = $this->safe_string($position, 'pos');
        $contractsAbs = Precise::string_abs($contractsString);
        $contracts = null;
        $side = $this->safe_string($position, 'posSide');
        $hedged = $side !== 'net';
        if ($contractsString !== null) {
            $contracts = $this->parse_number($contractsAbs);
            if ($side === 'net') {
                if (Precise::string_gt($contractsString, '0')) {
                    $side = 'long';
                } else {
                    $side = 'short';
                }
            }
        }
        $markPriceString = $this->safe_string($position, 'markPx');
        $notionalString = $this->safe_string($position, 'notionalUsd');
        if ($market['inverse']) {
            $notionalString = Precise::string_div($notionalString, $markPriceString);
        }
        $notional = $this->parse_number($notionalString);
        $marginType = $this->safe_string($position, 'mgnMode');
        $initialMarginString = null;
        $entryPriceString = $this->safe_string($position, 'avgPx');
        $unrealizedPnlString = $this->safe_string($position, 'upl');
        $leverageString = $this->safe_string($position, 'lever');
        $initialMarginPercentage = null;
        $collateralString = null;
        if ($marginType === 'cross') {
            $initialMarginString = $this->safe_string($position, 'imr');
            $collateralString = Precise::string_add($initialMarginString, $unrealizedPnlString);
        } else if ($marginType === 'isolated') {
            $initialMarginPercentage = Precise::string_div('1', $leverageString);
            $collateralString = $this->safe_string($position, 'margin');
        }
        $maintenanceMarginString = $this->safe_string($position, 'mmr');
        $maintenanceMargin = $this->parse_number($maintenanceMarginString);
        $maintenanceMarginPercentage = Precise::string_div($maintenanceMarginString, $notionalString);
        if ($initialMarginPercentage === null) {
            $initialMarginPercentage = $this->parse_number(Precise::string_div($initialMarginString, $notionalString, 4));
        } else if ($initialMarginString === null) {
            $initialMarginString = Precise::string_mul($initialMarginPercentage, $notionalString);
        }
        $rounder = '0.00005'; // round to closest 0.01%
        $maintenanceMarginPercentage = $this->parse_number(Precise::string_div(Precise::string_add($maintenanceMarginPercentage, $rounder), '1', 4));
        $liquidationPrice = $this->safe_number($position, 'liqPx');
        $percentageString = $this->safe_string($position, 'uplRatio');
        $percentage = $this->parse_number(Precise::string_mul($percentageString, '100'));
        $timestamp = $this->safe_integer($position, 'uTime');
        $marginRatio = $this->parse_number(Precise::string_div($maintenanceMarginString, $collateralString, 4));
        return array(
            'info' => $position,
            'symbol' => $symbol,
            'notional' => $notional,
            'marginType' => $marginType,
            'liquidationPrice' => $liquidationPrice,
            'entryPrice' => $this->parse_number($entryPriceString),
            'unrealizedPnl' => $this->parse_number($unrealizedPnlString),
            'percentage' => $percentage,
            'contracts' => $contracts,
            'contractSize' => $this->parse_number($market['contractSize']),
            'markPrice' => $this->parse_number($markPriceString),
            'side' => $side,
            'hedged' => $hedged,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'maintenanceMargin' => $maintenanceMargin,
            'maintenanceMarginPercentage' => $maintenanceMarginPercentage,
            'collateral' => $this->parse_number($collateralString),
            'initialMargin' => $this->parse_number($initialMarginString),
            'initialMarginPercentage' => $this->parse_number($initialMarginPercentage),
            'leverage' => $this->parse_number($leverageString),
            'marginRatio' => $marginRatio,
        );
    }

    public function transfer($code, $amount, $fromAccount, $toAccount, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $accountsByType = $this->safe_value($this->options, 'accountsByType', array());
        $fromId = $this->safe_string($accountsByType, $fromAccount);
        $toId = $this->safe_string($accountsByType, $toAccount);
        if ($fromId === null) {
            $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
            throw new ExchangeError($this->id . ' $fromAccount must be one of ' . implode(', ', $keys));
        }
        if ($toId === null) {
            $keys = is_array($accountsByType) ? array_keys($accountsByType) : array();
            throw new ExchangeError($this->id . ' $toAccount must be one of ' . implode(', ', $keys));
        }
        $request = array(
            'ccy' => $currency['id'],
            'amt' => $this->currency_to_precision($code, $amount),
            'type' => '0', // 0 = transfer within account by default, 1 = master account to sub-account, 2 = sub-account to master account
            'from' => $fromId, // remitting account, 1 = SPOT, 3 = FUTURES, 5 = MARGIN, 6 = FUNDING, 9 = SWAP, 12 = OPTION, 18 = Unified account
            'to' => $toId, // beneficiary account, 1 = SPOT, 3 = FUTURES, 5 = MARGIN, 6 = FUNDING, 9 = SWAP, 12 = OPTION, 18 = Unified account
            // 'subAcct' => 'sub-account-name', // optional, only required when type is 1 or 2
            // 'instId' => market['id'], // required when from is 3, 5 or 9, margin trading pair like BTC-USDT or contract underlying like BTC-USD to be transferred out
            // 'toInstId' => market['id'], // required when from is 3, 5 or 9, margin trading pair like BTC-USDT or contract underlying like BTC-USD to be transferred in
        );
        $response = yield $this->privatePostAssetTransfer (array_merge($request, $params));
        //
        //     {
        //         "code" => "0",
        //         "msg" => "",
        //         "data" => array(
        //             {
        //                 "transId" => "754147",
        //                 "ccy" => "USDT",
        //                 "from" => "6",
        //                 "amt" => "0.1",
        //                 "to" => "18"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $rawTransfer = $this->safe_value($data, 0, array());
        return $this->parse_transfer($rawTransfer, $currency);
    }

    public function parse_transfer($transfer, $currency = null) {
        //
        // $transfer
        //
        //     {
        //         "transId" => "754147",
        //         "ccy" => "USDT",
        //         "from" => "6",
        //         "amt" => "0.1",
        //         "to" => "18"
        //     }
        //
        $id = $this->safe_string($transfer, 'transId');
        $currencyId = $this->safe_string($transfer, 'ccy');
        $code = $this->safe_currency_code($currencyId, $currency);
        $amount = $this->safe_number($transfer, 'amt');
        $fromAccountId = $this->safe_string($transfer, 'from');
        $toAccountId = $this->safe_string($transfer, 'to');
        $typesByAccount = $this->safe_value($this->options, 'typesByAccount', array());
        $fromAccount = $this->safe_string($typesByAccount, $fromAccountId);
        $toAccount = $this->safe_string($typesByAccount, $toAccountId);
        $timestamp = null;
        $status = null;
        return array(
            'info' => $transfer,
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'currency' => $code,
            'amount' => $amount,
            'fromAccount' => $fromAccount,
            'toAccount' => $toAccount,
            'status' => $status,
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $isArray = gettype($params) === 'array' && count(array_filter(array_keys($params), 'is_string')) == 0;
        $request = '/api/' . $this->version . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        $url = $this->implode_hostname($this->urls['api']['rest']) . $request;
        // $type = $this->getPathAuthenticationType ($path);
        if ($api === 'public') {
            if ($query) {
                $url .= '?' . $this->urlencode($query);
            }
        } else if ($api === 'private') {
            $this->check_required_credentials();
            $timestamp = $this->iso8601($this->milliseconds());
            $headers = array(
                'OK-ACCESS-KEY' => $this->apiKey,
                'OK-ACCESS-PASSPHRASE' => $this->password,
                'OK-ACCESS-TIMESTAMP' => $timestamp,
                // 'OK-FROM' => '',
                // 'OK-TO' => '',
                // 'OK-LIMIT' => '',
            );
            $auth = $timestamp . $method . $request;
            if ($method === 'GET') {
                if ($query) {
                    $urlencodedQuery = '?' . $this->urlencode($query);
                    $url .= $urlencodedQuery;
                    $auth .= $urlencodedQuery;
                }
            } else {
                if ($isArray || $query) {
                    $body = $this->json($query);
                    $auth .= $body;
                }
                $headers['Content-Type'] = 'application/json';
            }
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256', 'base64');
            $headers['OK-ACCESS-SIGN'] = $signature;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function parse_funding_rate($fundingRate, $market = null) {
        //
        //     {
        //       "fundingRate" => "0.00027815",
        //       "fundingTime" => "1634256000000",
        //       "instId" => "BTC-USD-SWAP",
        //       "instType" => "SWAP",
        //       "nextFundingRate" => "0.00017",
        //       "nextFundingTime" => "1634284800000"
        //     }
        //
        // in the response above $nextFundingRate is actually two funding rates from now
        //
        $nextFundingRateTimestamp = $this->safe_integer($fundingRate, 'fundingTime');
        $marketId = $this->safe_string($fundingRate, 'instId');
        $symbol = $this->safe_symbol($marketId, $market);
        $nextFundingRate = $this->safe_number($fundingRate, 'fundingRate');
        // https://www.okex.com/support/hc/en-us/articles/360053909272-Ⅸ-Introduction-to-perpetual-swap-funding-fee
        // > The current interest is 0.
        return array(
            'info' => $fundingRate,
            'symbol' => $symbol,
            'markPrice' => null,
            'indexPrice' => null,
            'interestRate' => $this->parse_number('0'),
            'estimatedSettlePrice' => null,
            'timestamp' => null,
            'datetime' => null,
            'previousFundingRate' => null,
            'nextFundingRate' => $nextFundingRate,
            'previousFundingTimestamp' => null,
            'nextFundingTimestamp' => $nextFundingRateTimestamp,
            'previousFundingDatetime' => null,
            'nextFundingDatetime' => $this->iso8601($nextFundingRateTimestamp),
        );
    }

    public function fetch_funding_rate($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        if (!$market['swap']) {
            throw new ExchangeError($this->id . ' fetchFundingRate is only valid for swap markets');
        }
        $request = array(
            'instId' => $market['id'],
        );
        $response = yield $this->publicGetPublicFundingRate (array_merge($request, $params));
        //
        //     {
        //       "code" => "0",
        //       "data" => array(
        //         {
        //           "fundingRate" => "0.00027815",
        //           "fundingTime" => "1634256000000",
        //           "instId" => "BTC-USD-SWAP",
        //           "instType" => "SWAP",
        //           "nextFundingRate" => "0.00017",
        //           "nextFundingTime" => "1634284800000"
        //         }
        //       ),
        //       "msg" => ""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $entry = $this->safe_value($data, 0, array());
        return $this->parse_funding_rate($entry, $market);
    }

    public function fetch_funding_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'instType' => 'SPOT', // SPOT, MARGIN, SWAP, FUTURES, OPTION
            // 'ccy' => currency['id'],
            // 'mgnMode' => 'isolated', // isolated, cross
            // 'ctType' => 'linear', // linear, inverse, only applicable to FUTURES/SWAP
            'type' => '8',
            //
            // supported values for type
            //
            //     1 Transfer
            //     2 Trade
            //     3 Delivery
            //     4 Auto token conversion
            //     5 Liquidation
            //     6 Margin transfer
            //     7 Interest deduction
            //     8 Funding fee
            //     9 ADL
            //     10 Clawback
            //     11 System token conversion
            //     12 Strategy transfer
            //     13 ddh
            //
            // 'subType' => '',
            //
            // supported values for subType
            //
            //     1 Buy
            //     2 Sell
            //     3 Open long
            //     4 Open short
            //     5 Close long
            //     6 Close short
            //     9 Interest deduction
            //     11 Transfer in
            //     12 Transfer out
            //     160 Manual margin increase
            //     161 Manual margin decrease
            //     162 Auto margin increase
            //     110 Auto buy
            //     111 Auto sell
            //     118 System token conversion transfer in
            //     119 System token conversion transfer out
            //     100 Partial liquidation close long
            //     101 Partial liquidation close short
            //     102 Partial liquidation buy
            //     103 Partial liquidation sell
            //     104 Liquidation long
            //     105 Liquidation short
            //     106 Liquidation buy
            //     107 Liquidation sell
            //     110 Liquidation transfer in
            //     111 Liquidation transfer out
            //     125 ADL close long
            //     126 ADL close short
            //     127 ADL buy
            //     128 ADL sell
            //     131 ddh buy
            //     132 ddh sell
            //     170 Exercised
            //     171 Counterparty exercised
            //     172 Expired OTM
            //     112 Delivery long
            //     113 Delivery short
            //     117 Delivery/Exercise clawback
            //     173 Funding fee expense
            //     174 Funding fee income
            //     200 System transfer in
            //     201 Manually transfer in
            //     202 System transfer out
            //     203 Manually transfer out
            //
            // 'after' => 'id', // earlier than the requested bill ID
            // 'before' => 'id', // newer than the requested bill ID
            // 'limit' => '100', // default 100, max 100
        );
        if ($limit !== null) {
            $request['limit'] = (string) $limit; // default 100, max 100
        }
        $response = yield $this->privateGetAccountBills (array_merge($request, $params));
        //
        //     {
        //       "bal" => "0.0242946200998573",
        //       "balChg" => "0.0000148752712240",
        //       "billId" => "377970609204146187",
        //       "ccy" => "ETH",
        //       "execType" => "",
        //       "fee" => "0",
        //       "from" => "",
        //       "instId" => "ETH-USD-SWAP",
        //       "instType" => "SWAP",
        //       "mgnMode" => "isolated",
        //       "notes" => "",
        //       "ordId" => "",
        //       "pnl" => "0.000014875271224",
        //       "posBal" => "0",
        //       "posBalChg" => "0",
        //       "subType" => "174",
        //       "sz" => "9",
        //       "to" => "",
        //       "ts" => "1636387215588",
        //       "type" => "8"
        //     }
        //
        $data = $this->safe_value($response, 'data');
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $entry = $data[$i];
            $timestamp = $this->safe_integer($entry, 'ts');
            $instId = $this->safe_string($entry, 'instId');
            $market = $this->safe_market($instId);
            $result[] = array(
                'info' => $entry,
                'symbol' => $market['symbol'],
                'code' => $market['inverse'] ? $market['base'] : $market['quote'],
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'id' => $this->safe_string($entry, 'billId'),
                'amount' => $this->safe_number($entry, 'balChg'),
            );
        }
        $sorted = $this->sort_by($result, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        // WARNING => THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (($leverage < 1) || ($leverage > 125)) {
            throw new BadRequest($this->id . ' setLeverage $leverage should be between 1 and 125');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $marginMode = $this->safe_string_lower($params, 'mgnMode');
        $params = $this->omit($params, array( 'mgnMode' ));
        if (($marginMode !== 'cross') && ($marginMode !== 'isolated')) {
            throw new BadRequest($this->id . ' setLeverage $params["mgnMode"] must be either "cross" or "isolated"');
        }
        $request = array(
            'lever' => $leverage,
            'mgnMode' => $marginMode,
            'instId' => $market['id'],
        );
        $response = yield $this->privatePostAccountSetLeverage (array_merge($request, $params));
        //
        //     {
        //       "code" => "0",
        //       "data" => array(
        //         {
        //           "instId" => "BTC-USDT-SWAP",
        //           "lever" => "5",
        //           "mgnMode" => "isolated",
        //           "posSide" => "long"
        //         }
        //       ),
        //       "msg" => ""
        //     }
        //
        return $response;
    }

    public function set_position_mode($hedged, $symbol = null, $params = array ()) {
        $hedgeMode = null;
        if ($hedged) {
            $hedgeMode = 'long_short_mode';
        } else {
            $hedgeMode = 'net_mode';
        }
        $request = array(
            'posMode' => $hedgeMode,
        );
        $response = yield $this->privatePostAccountSetPositionMode (array_merge($request, $params));
        //
        //     {
        //       "code" => "0",
        //       "data" => array(
        //         {
        //           "posMode" => "net_mode"
        //         }
        //       ),
        //       "msg" => ""
        //     }
        //
        return $response;
    }

    public function set_margin_mode($marginType, $symbol = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
        }
        // WARNING => THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (($marginType !== 'cross') && ($marginType !== 'isolated')) {
            throw new BadRequest($this->id . ' setMarginMode $marginType must be either "cross" or "isolated"');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $lever = $this->safe_integer($params, 'lever');
        if (($lever === null) || ($lever < 1) || ($lever > 125)) {
            throw new BadRequest($this->id . ' setMarginMode $params["lever"] should be between 1 and 125');
        }
        $params = $this->omit($params, array( 'lever' ));
        $request = array(
            'lever' => $lever,
            'mgnMode' => $marginType,
            'instId' => $market['id'],
        );
        $response = yield $this->privatePostAccountSetLeverage (array_merge($request, $params));
        //
        //     {
        //       "code" => "0",
        //       "data" => array(
        //         {
        //           "instId" => "BTC-USDT-SWAP",
        //           "lever" => "5",
        //           "mgnMode" => "isolated",
        //           "posSide" => "long"
        //         }
        //       ),
        //       "msg" => ""
        //     }
        //
        return $response;
    }

    public function modify_margin_helper($symbol, $amount, $type, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $posSide = $this->safe_string($params, 'posSide', 'net');
        $params = $this->omit($params, array( 'posSide' ));
        $request = array(
            'instId' => $market['id'],
            'amt' => $amount,
            'type' => $type,
            'posSide' => $posSide,
        );
        $response = yield $this->privatePostAccountPositionMarginBalance (array_merge($request, $params));
        //
        //     {
        //       "code" => "0",
        //       "data" => array(
        //         {
        //           "amt" => "0.01",
        //           "instId" => "ETH-USD-SWAP",
        //           "posSide" => "net",
        //           "type" => "reduce"
        //         }
        //       ),
        //       "msg" => ""
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $entry = $this->safe_value($data, 0, array());
        $errorCode = $this->safe_string($response, 'code');
        $status = ($errorCode === '0') ? 'ok' : 'failed';
        $responseAmount = $this->safe_number($entry, 'amt');
        $responseType = $this->safe_string($entry, 'type');
        $marketId = $this->safe_string($entry, 'instId');
        $responseMarket = $this->safe_market($marketId, $market);
        $code = $responseMarket['inverse'] ? $responseMarket['base'] : $responseMarket['quote'];
        $symbol = $responseMarket['symbol'];
        return array(
            'info' => $response,
            'type' => $responseType,
            'amount' => $responseAmount,
            'code' => $code,
            'symbol' => $symbol,
            'status' => $status,
        );
    }

    public function fetch_borrow_rates($params = array ()) {
        yield $this->load_markets();
        $response = yield $this->privateGetAccountInterestRate ($params);
        // {
        //     "code" => "0",
        //     "data" => array(
        //         {
        //             "ccy":"BTC",
        //             "interestRate":"0.00000833"
        //         }
        //         ...
        //     ),
        // }
        $timestamp = $this->milliseconds();
        $data = $this->safe_value($response, 'data');
        $rates = array();
        for ($i = 0; $i < count($data); $i++) {
            $rate = $data[$i];
            $code = $this->safe_currency_code($this->safe_string($rate, 'ccy'));
            $rates[$code] = array(
                'currency' => $code,
                'rate' => $this->safe_number($rate, 'interestRate'),
                'period' => 86400000,
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
                'info' => $rate,
            );
        }
        return $rates;
    }

    public function fetch_borrow_rate($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'ccy' => $currency['id'],
        );
        $response = yield $this->privateGetAccountInterestRate (array_merge($request, $params));
        // {
        //     "code" => "0",
        //     "data":array(
        //          {
        //             "ccy":"USDT",
        //             "interestRate":"0.00002065"
        //          }
        //          ...
        //     ),
        //     "msg":""
        // }
        $timestamp = $this->milliseconds();
        $data = $this->safe_value($response, 'data');
        $rate = $this->safe_value($data, 0);
        return array(
            'currency' => $code,
            'rate' => $this->safe_number($rate, 'interestRate'),
            'period' => 86400000,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'info' => $rate,
        );
    }

    public function reduce_margin($symbol, $amount, $params = array ()) {
        return yield $this->modify_margin_helper($symbol, $amount, 'reduce', $params);
    }

    public function add_margin($symbol, $amount, $params = array ()) {
        return yield $this->modify_margin_helper($symbol, $amount, 'add', $params);
    }

    public function set_sandbox_mode($enable) {
        if ($enable) {
            $this->headers['x-simulated-trading'] = 1;
        } else {
            $this->headers['x-simulated-trading'] = null;
        }
    }

    public function handle_errors($httpCode, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if (!$response) {
            return; // fallback to default $error handler
        }
        //
        //     array("code":"1","data":[array("clOrdId":"","ordId":"","sCode":"51119","sMsg":"Order placement failed due to insufficient balance. ","tag":"")],"msg":"")
        //     array("code":"58001","data":array(),"msg":"Incorrect trade password")
        //
        $code = $this->safe_string($response, 'code');
        if ($code !== '0') {
            $feedback = $this->id . ' ' . $body;
            $data = $this->safe_value($response, 'data', array());
            for ($i = 0; $i < count($data); $i++) {
                $error = $data[$i];
                $errorCode = $this->safe_string($error, 'sCode');
                $message = $this->safe_string($error, 'sMsg');
                $this->throw_exactly_matched_exception($this->exceptions['exact'], $errorCode, $feedback);
                $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            }
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $code, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
    }
}
