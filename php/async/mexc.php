<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\ArgumentsRequired;
use \ccxt\InvalidAddress;
use \ccxt\InvalidOrder;
use \ccxt\OrderNotFound;
use \ccxt\Precise;

class mexc extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'mexc',
            'name' => 'MEXC Global',
            'countries' => array( 'SC' ), // Seychelles
            'rateLimit' => 50, // default rate limit is 20 times per second
            'version' => 'v2',
            'certified' => true,
            'has' => array(
                'addMargin' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'createMarketOrder' => false,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchCanceledOrders' => true,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => true,
                'fetchDepositAddress' => true,
                'fetchDepositAddressesByNetwork' => true,
                'fetchDeposits' => true,
                'fetchFundingRateHistory' => true,
                'fetchMarkets' => true,
                'fetchMarketsByType' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrdersByState' => true,
                'fetchOrderTrades' => true,
                'fetchPosition' => true,
                'fetchPositions' => true,
                'fetchStatus' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTime' => true,
                'fetchTrades' => true,
                'fetchWithdrawals' => true,
                'reduceMargin' => true,
                'setLeverage' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '1d' => '1d',
                '1M' => '1M',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg',
                'api' => array(
                    'spot' => array(
                        'public' => 'https://www.mexc.com/open/api/v2',
                        'private' => 'https://www.mexc.com/open/api/v2',
                    ),
                    'contract' => array(
                        'public' => 'https://contract.mexc.com/api/v1/contract',
                        'private' => 'https://contract.mexc.com/api/v1/private',
                    ),
                ),
                'www' => 'https://www.mexc.com/',
                'doc' => array(
                    'https://mxcdevelop.github.io/APIDoc/',
                ),
                'fees' => array(
                    'https://www.mexc.com/fee',
                ),
                'referral' => 'https://m.mexc.com/auth/signup?inviteCode=1FQ1G',
            ),
            'api' => array(
                'contract' => array(
                    'public' => array(
                        'get' => array(
                            'ping' => 2,
                            'detail' => 2,
                            'support_currencies' => 2,
                            'depth/{symbol}' => 2,
                            'depth_commits/{symbol}/{limit}' => 2,
                            'index_price/{symbol}' => 2,
                            'fair_price/{symbol}' => 2,
                            'funding_rate/{symbol}' => 2,
                            'kline/{symbol}' => 2,
                            'kline/index_price/{symbol}' => 2,
                            'kline/fair_price/{symbol}' => 2,
                            'deals/{symbol}' => 2,
                            'ticker' => 2,
                            'risk_reverse' => 2,
                            'risk_reverse/history' => 2,
                            'funding_rate/history' => 2,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/assets' => 2,
                            'account/asset/{currency}' => 2,
                            'account/transfer_record' => 2,
                            'position/list/history_positions' => 2,
                            'position/open_positions' => 2,
                            'position/funding_records' => 2,
                            'order/list/open_orders/{symbol}' => 2,
                            'order/list/history_orders' => 2,
                            'order/external/{symbol}/{external_oid}' => 2,
                            'order/get/{order_id}' => 2,
                            'order/batch_query' => 8,
                            'order/deal_details/{order_id}' => 2,
                            'order/list/order_deals' => 2,
                            'planorder/list/orders' => 2,
                            'stoporder/list/orders' => 2,
                            'stoporder/order_details/{stop_order_id}' => 2,
                            'account/risk_limit' => 2,
                            'account/tiered_fee_rate' => 2,
                        ),
                        'post' => array(
                            'position/change_margin' => 2,
                            'position/change_leverage' => 2,
                            'order/submit' => 2,
                            'order/submit_batch' => 40,
                            'order/cancel' => 2,
                            'order/cancel_with_external' => 2,
                            'order/cancel_all' => 2,
                            'account/change_risk_level' => 2,
                            'planorder/place' => 2,
                            'planorder/cancel' => 2,
                            'planorder/cancel_all' => 2,
                            'stoporder/cancel' => 2,
                            'stoporder/cancel_all' => 2,
                            'stoporder/change_price' => 2,
                            'stoporder/change_plan_price' => 2,
                        ),
                    ),
                ),
                'spot' => array(
                    'public' => array(
                        'get' => array(
                            'market/symbols' => 1,
                            'market/coin/list' => 2,
                            'common/timestamp' => 1,
                            'common/ping' => 1,
                            'market/ticker' => 1,
                            'market/depth' => 1,
                            'market/deals' => 1,
                            'market/kline' => 1,
                        ),
                    ),
                    'private' => array(
                        'get' => array(
                            'account/info' => 1,
                            'order/open_orders' => 1,
                            'order/list' => 1,
                            'order/query' => 1,
                            'order/deals' => 1,
                            'order/deal_detail' => 1,
                            'asset/deposit/address/list' => 2,
                            'asset/deposit/list' => 2,
                            'asset/address/list' => 2,
                            'asset/withdraw/list' => 2,
                        ),
                        'post' => array(
                            'order/place' => 1,
                            'order/place_batch' => 1,
                            'asset/withdraw' => 1,
                        ),
                        'delete' => array(
                            'order/cancel' => 1,
                            'order/cancel_by_symbol' => 1,
                        ),
                    ),
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'maker' => 0.2 / 100, // maker / taker
                    'taker' => 0.2 / 100,
                ),
            ),
            'options' => array(
                'timeframes' => array(
                    'spot' => array(
                        '1m' => '1m',
                        '5m' => '5m',
                        '15m' => '15m',
                        '30m' => '30m',
                        '1h' => '1h',
                        '1d' => '1d',
                        '1M' => '1M',
                    ),
                    'contract' => array(
                        '1m' => 'Min1',
                        '5m' => 'Min5',
                        '15m' => 'Min15',
                        '30m' => 'Min30',
                        '1h' => 'Min60',
                        '4h' => 'Hour4',
                        '8h' => 'Hour8',
                        '1d' => 'Day1',
                        '1w' => 'Week1',
                        '1M' => 'Month1',
                    ),
                ),
                'defaultType' => 'spot', // spot, swap
                'networks' => array(
                    'TRX' => 'TRC-20',
                    'TRC20' => 'TRC-20',
                    'ETH' => 'ERC-20',
                    'ERC20' => 'ERC-20',
                    'BEP20' => 'BEP20(BSC)',
                ),
            ),
            'commonCurrencies' => array(
                'BYN' => 'BeyondFi',
                'COFI' => 'COFIX', // conflict with CoinFi
                'DFT' => 'dFuture',
                'DRK' => 'DRK',
                'FLUX1' => 'FLUX', // switched places
                'FLUX' => 'FLUX1', // switched places
                'FREE' => 'FreeRossDAO', // conflict with FREE Coin
                'HERO' => 'Step Hero', // conflict with Metahero
                'MIMO' => 'Mimosa',
                'PROS' => 'Pros.Finance', // conflict with Prosper
                'SIN' => 'Sin City Token',
            ),
            'exceptions' => array(
                'exact' => array(
                    '400' => '\\ccxt\\BadRequest', // Invalid parameter
                    '401' => '\\ccxt\\AuthenticationError', // Invalid signature, fail to pass the validation
                    '429' => '\\ccxt\\RateLimitExceeded', // too many requests, rate limit rule is violated
                    '1000' => '\\ccxt\\PermissionDenied', // array("success":false,"code":1000,"message":"Please open contract account first!")
                    '1002' => '\\ccxt\\InvalidOrder', // array("success":false,"code":1002,"message":"Contract not allow place order!")
                    '10072' => '\\ccxt\\AuthenticationError', // Invalid access key
                    '10073' => '\\ccxt\\AuthenticationError', // Invalid request time
                    '10216' => '\\ccxt\\InvalidAddress', // array("code":10216,"msg":"No available deposit address")
                    '10232' => '\\ccxt\\BadSymbol', // array("code":10232,"msg":"The currency not exist")
                    '30000' => '\\ccxt\\BadSymbol', // Trading is suspended for the requested symbol
                    '30001' => '\\ccxt\\InvalidOrder', // Current trading type (bid or ask) is not allowed
                    '30002' => '\\ccxt\\InvalidOrder', // Invalid trading amount, smaller than the symbol minimum trading amount
                    '30003' => '\\ccxt\\InvalidOrder', // Invalid trading amount, greater than the symbol maximum trading amount
                    '30004' => '\\ccxt\\InsufficientFunds', // Insufficient balance
                    '30005' => '\\ccxt\\InvalidOrder', // Oversell error
                    '30010' => '\\ccxt\\InvalidOrder', // Price out of allowed range
                    '30016' => '\\ccxt\\BadSymbol', // Market is closed
                    '30019' => '\\ccxt\\InvalidOrder', // Orders count over limit for batch processing
                    '30020' => '\\ccxt\\BadSymbol', // Restricted symbol, API access is not allowed for the time being
                    '30021' => '\\ccxt\\BadSymbol', // Invalid symbol
                    '33333' => '\\ccxt\\BadSymbol', // array("code":33333,"msg":"currency can not be null")
                ),
                'broad' => array(
                ),
            ),
        ));
    }

    public function fetch_time($params = array ()) {
        $defaultType = $this->safe_string_2($this->options, 'fetchMarkets', 'defaultType', 'spot');
        $type = $this->safe_string($params, 'type', $defaultType);
        $query = $this->omit($params, 'type');
        $method = 'spotPublicGetCommonTimestamp';
        if ($type === 'contract') {
            $method = 'contractPublicGetPing';
        }
        $response = yield $this->$method ($query);
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":1633375641837
        //     }
        //
        // contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":1634095541710
        //     }
        //
        return $this->safe_integer($response, 'data');
    }

    public function fetch_status($params = array ()) {
        $response = yield $this->spotPublicGetCommonPing ($params);
        //
        // array( "code":200 )
        //
        $code = $this->safe_integer($response, 'code');
        if ($code !== null) {
            $status = ($code === 200) ? 'ok' : 'maintenance';
            $this->status = array_merge($this->status, array(
                'status' => $status,
                'updated' => $this->milliseconds(),
            ));
        }
        return $this->status;
    }

    public function fetch_currencies($params = array ()) {
        $response = yield $this->spotPublicGetMarketCoinList ($params);
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "currency":"AGLD",
        //                 "coins":array(
        //                     array(
        //                         "chain":"ERC20",
        //                         "precision":18,
        //                         "fee":8.09,
        //                         "is_withdraw_enabled":true,
        //                         "is_deposit_enabled":true,
        //                         "deposit_min_confirm":16,
        //                         "withdraw_limit_max":500000.0,
        //                         "withdraw_limit_min":14.0
        //                     }
        //                 ),
        //                 "full_name":"Adventure Gold"
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $currency = $data[$i];
            $id = $this->safe_string($currency, 'currency');
            $code = $this->safe_currency_code($id);
            $name = $this->safe_string($currency, 'full_name');
            $currencyActive = false;
            $currencyPrecision = null;
            $currencyFee = null;
            $currencyWithdrawMin = null;
            $currencyWithdrawMax = null;
            $networks = array();
            $chains = $this->safe_value($currency, 'coins', array());
            for ($j = 0; $j < count($chains); $j++) {
                $chain = $chains[$j];
                $networkId = $this->safe_string($chain, 'chain');
                $network = $this->safe_network($networkId);
                $isDepositEnabled = $this->safe_value($chain, 'is_deposit_enabled', false);
                $isWithdrawEnabled = $this->safe_value($chain, 'is_withdraw_enabled', false);
                $active = ($isDepositEnabled && $isWithdrawEnabled);
                $currencyActive = $active || $currencyActive;
                $precisionDigits = $this->safe_integer($chain, 'precision');
                $precision = 1 / pow(10, $precisionDigits);
                $withdrawMin = $this->safe_string($chain, 'withdraw_limit_min');
                $withdrawMax = $this->safe_string($chain, 'withdraw_limit_max');
                $currencyWithdrawMin = ($currencyWithdrawMin === null) ? $withdrawMin : $currencyWithdrawMin;
                $currencyWithdrawMax = ($currencyWithdrawMax === null) ? $withdrawMax : $currencyWithdrawMax;
                if (Precise::string_gt($currencyWithdrawMin, $withdrawMin)) {
                    $currencyWithdrawMin = $withdrawMin;
                }
                if (Precise::string_lt($currencyWithdrawMax, $withdrawMax)) {
                    $currencyWithdrawMax = $withdrawMax;
                }
                $networks[$network] = array(
                    'info' => $chain,
                    'id' => $networkId,
                    'network' => $network,
                    'active' => $active,
                    'fee' => $this->safe_number($chain, 'fee'),
                    'precision' => $precision,
                    'limits' => array(
                        'withdraw' => array(
                            'min' => $withdrawMin,
                            'max' => $withdrawMax,
                        ),
                    ),
                );
            }
            $networkKeys = is_array($networks) ? array_keys($networks) : array();
            $networkKeysLength = is_array($networkKeys) ? count($networkKeys) : 0;
            if (($networkKeysLength === 1) || (is_array($networks) && array_key_exists('NONE', $networks))) {
                $defaultNetwork = $this->safe_value_2($networks, 'NONE', $networkKeysLength - 1);
                if ($defaultNetwork !== null) {
                    $currencyFee = $defaultNetwork['fee'];
                    $currencyPrecision = $defaultNetwork['precision'];
                }
            }
            $result[$code] = array(
                'id' => $id,
                'code' => $code,
                'info' => $currency,
                'name' => $name,
                'active' => $currencyActive,
                'fee' => $currencyFee,
                'precision' => $currencyPrecision,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => $currencyWithdrawMin,
                        'max' => $currencyWithdrawMax,
                    ),
                ),
                'networks' => $networks,
            );
        }
        return $result;
    }

    public function fetch_markets_by_type($type, $params = array ()) {
        $method = 'fetch_' . $type . '_markets';
        return yield $this->$method ($params);
    }

    public function fetch_markets($params = array ()) {
        $defaultType = $this->safe_string_2($this->options, 'fetchMarkets', 'defaultType', 'spot');
        $type = $this->safe_string($params, 'type', $defaultType);
        $query = $this->omit($params, 'type');
        $spot = ($type === 'spot');
        $swap = ($type === 'swap');
        if (!$spot && !$swap) {
            throw new ExchangeError($this->id . " does not support '" . $type . "' $type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'"); // eslint-disable-line quotes
        }
        if ($spot) {
            return yield $this->fetch_spot_markets($query);
        } else if ($swap) {
            return yield $this->fetch_contract_markets($query);
        }
    }

    public function fetch_contract_markets($params = array ()) {
        $response = yield $this->contractPublicGetDetail ($params);
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":[
        //             array(
        //                 "symbol":"BTC_USDT",
        //                 "displayName":"BTC_USDT永续",
        //                 "displayNameEn":"BTC_USDT SWAP",
        //                 "positionOpenType":3,
        //                 "baseCoin":"BTC",
        //                 "quoteCoin":"USDT",
        //                 "settleCoin":"USDT",
        //                 "contractSize":0.0001,
        //                 "minLeverage":1,
        //                 "maxLeverage":125,
        //                 "priceScale":2,
        //                 "volScale":0,
        //                 "amountScale":4,
        //                 "priceUnit":0.5,
        //                 "volUnit":1,
        //                 "minVol":1,
        //                 "maxVol":1000000,
        //                 "bidLimitPriceRate":0.1,
        //                 "askLimitPriceRate":0.1,
        //                 "takerFeeRate":0.0006,
        //                 "makerFeeRate":0.0002,
        //                 "maintenanceMarginRate":0.004,
        //                 "initialMarginRate":0.008,
        //                 "riskBaseVol":10000,
        //                 "riskIncrVol":200000,
        //                 "riskIncrMmr":0.004,
        //                 "riskIncrImr":0.004,
        //                 "riskLevelLimit":5,
        //                 "priceCoefficientVariation":0.1,
        //                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
        //                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
        //                 "isNew":false,
        //                 "isHot":true,
        //                 "isHidden":false
        //             ),
        //         ]
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'baseCoin');
            $quoteId = $this->safe_string($market, 'quoteCoin');
            $settleId = $this->safe_string($market, 'settleCoin');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $settle = $this->safe_currency_code($settleId);
            $state = $this->safe_string($market, 'state');
            $result[] = array(
                'id' => $id,
                'symbol' => $base . '/' . $quote . ':' . $settle,
                'base' => $base,
                'quote' => $quote,
                'settle' => $settle,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => $settleId,
                'type' => 'swap',
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'futures' => false,
                'option' => false,
                'derivative' => true,
                'contract' => true,
                'linear' => true,
                'inverse' => false,
                'taker' => $this->safe_number($market, 'takerFeeRate'),
                'maker' => $this->safe_number($market, 'makerFeeRate'),
                'contractSize' => $this->safe_string($market, 'contractSize'),
                'active' => ($state === '0'),
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'price' => $this->safe_number($market, 'priceUnit'),
                    'amount' => $this->safe_number($market, 'volUnit'),
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => $this->safe_number($market, 'minLeverage'),
                        'max' => $this->safe_number($market, 'maxLeverage'),
                    ),
                    'amount' => array(
                        'min' => $this->safe_number($market, 'minVol'),
                        'max' => $this->safe_number($market, 'maxVol'),
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_spot_markets($params = array ()) {
        $response = yield $this->spotPublicGetMarketSymbols ($params);
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             array(
        //                 "symbol":"DFD_USDT",
        //                 "state":"ENABLED",
        //                 "countDownMark":1,
        //                 "vcoinName":"DFD",
        //                 "vcoinStatus":1,
        //                 "price_scale":4,
        //                 "quantity_scale":2,
        //                 "min_amount":"5", // not an amount = cost
        //                 "max_amount":"5000000",
        //                 "maker_fee_rate":"0.002",
        //                 "taker_fee_rate":"0.002",
        //                 "limited":true,
        //                 "etf_mark":0,
        //                 "symbol_partition":"ASSESS"
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'symbol');
            list($baseId, $quoteId) = explode('_', $id);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $priceScale = $this->safe_integer($market, 'price_scale');
            $quantityScale = $this->safe_integer($market, 'quantity_scale');
            $pricePrecision = 1 / pow(10, $priceScale);
            $quantityPrecision = 1 / pow(10, $quantityScale);
            $state = $this->safe_string($market, 'state');
            $type = 'spot';
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'settle' => null,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'settleId' => null,
                'type' => $type,
                'spot' => true,
                'margin' => false,
                'swap' => false,
                'future' => false,
                'option' => false,
                'active' => ($state === 'ENABLED'),
                'derivative' => false,
                'contract' => false,
                'linear' => null,
                'inverse' => null,
                'taker' => $this->safe_number($market, 'taker_fee_rate'),
                'maker' => $this->safe_number($market, 'maker_fee_rate'),
                'contractSize' => null,
                'expiry' => null,
                'expiryDatetime' => null,
                'strike' => null,
                'optionType' => null,
                'precision' => array(
                    'price' => $pricePrecision,
                    'amount' => $quantityPrecision,
                ),
                'limits' => array(
                    'leverage' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => $this->safe_number($market, 'min_amount'),
                        'max' => $this->safe_number($market, 'max_amount'),
                    ),
                ),
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $defaultType = $this->safe_string_2($this->options, 'fetchTickers', 'defaultType', 'spot');
        $type = $this->safe_string($params, 'type', $defaultType);
        $query = $this->omit($params, 'type');
        $method = 'spotPublicGetMarketTicker';
        if ($type === 'swap') {
            $method = 'contractPublicGetTicker';
        }
        $response = yield $this->$method (array_merge($query));
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":array(
        //             array(
        //                 "symbol":"NKN_USDT",
        //                 "lastPrice":0.36199,
        //                 "bid1":0.35908,
        //                 "ask1":0.36277,
        //                 "volume24":657754,
        //                 "amount24":239024.53998,
        //                 "holdVol":149969,
        //                 "lower24Price":0.34957,
        //                 "high24Price":0.37689,
        //                 "riseFallRate":0.0117,
        //                 "riseFallValue":0.00419,
        //                 "indexPrice":0.36043,
        //                 "fairPrice":0.36108,
        //                 "fundingRate":0.000535,
        //                 "maxBidPrice":0.43251,
        //                 "minAskPrice":0.28834,
        //                 "timestamp":1634163352075
        //             ),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_tickers($data, $symbols);
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketTicker';
        } else if ($market['swap']) {
            $method = 'contractPublicGetTicker';
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "symbol":"BTC_USDT",
        //                 "volume":"880.821523",
        //                 "high":"49496.95", // highest price over the past 24 hours
        //                 "low":"46918.4", // lowest
        //                 "bid":"49297.64", // current buying price == the best price you can sell for
        //                 "ask":"49297.75", // current selling price == the best price you can buy for
        //                 "open":"48764.9", // open price 24h ago
        //                 "last":"49297.73", // last = close
        //                 "time":1633378200000, // timestamp
        //                 "change_rate":"0.0109265" // (last / open) - 1
        //             }
        //         )
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":{
        //             "symbol":"ETH_USDT",
        //             "lastPrice":3581.3,
        //             "bid1":3581.25,
        //             "ask1":3581.5,
        //             "volume24":4045530,
        //             "amount24":141331823.5755,
        //             "holdVol":5832946,
        //             "lower24Price":3413.4,
        //             "high24Price":3588.7,
        //             "riseFallRate":0.0275,
        //             "riseFallValue":95.95,
        //             "indexPrice":3580.7852,
        //             "fairPrice":3581.08,
        //             "fundingRate":0.000063,
        //             "maxBidPrice":3938.85,
        //             "minAskPrice":3222.7,
        //             "timestamp":1634162885016
        //         }
        //     }
        //
        if ($market['spot']) {
            $data = $this->safe_value($response, 'data', array());
            $ticker = $this->safe_value($data, 0);
            return $this->parse_ticker($ticker, $market);
        } else if ($market['swap']) {
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_ticker($data, $market);
        }
    }

    public function parse_ticker($ticker, $market = null) {
        //
        // spot
        //
        //     {
        //         "symbol":"BTC_USDT",
        //         "volume":"880.821523",
        //         "high":"49496.95",
        //         "low":"46918.4",
        //         "bid":"49297.64",
        //         "ask":"49297.75",
        //         "open":"48764.9",
        //         "last":"49297.73",
        //         "time":1633378200000,
        //         "change_rate":"0.0109265"
        //     }
        //
        // contract
        //
        //     {
        //         "symbol":"ETH_USDT",
        //         "lastPrice":3581.3,
        //         "bid1":3581.25,
        //         "ask1":3581.5,
        //         "volume24":4045530,
        //         "amount24":141331823.5755,
        //         "holdVol":5832946,
        //         "lower24Price":3413.4,
        //         "high24Price":3588.7,
        //         "riseFallRate":0.0275,
        //         "riseFallValue":95.95,
        //         "indexPrice":3580.7852,
        //         "fairPrice":3581.08,
        //         "fundingRate":0.000063,
        //         "maxBidPrice":3938.85,
        //         "minAskPrice":3222.7,
        //         "timestamp":1634162885016
        //     }
        //
        $timestamp = $this->safe_integer_2($ticker, 'time', 'timestamp');
        $marketId = $this->safe_string($ticker, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '_');
        $baseVolume = $this->safe_number_2($ticker, 'volume', 'volume24');
        $quoteVolume = $this->safe_number($ticker, 'amount24');
        $open = $this->safe_number($ticker, 'open');
        $lastString = $this->safe_string_2($ticker, 'last', 'lastPrice');
        $last = $this->parse_number($lastString);
        $change = $this->safe_number($ticker, 'riseFallValue');
        $riseFallRate = $this->safe_string($ticker, 'riseFallRate');
        $percentageString = Precise::string_add($riseFallRate, '1');
        $percentage = $this->parse_number($percentageString);
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $this->safe_number_2($ticker, 'high', 'high24Price'),
            'low' => $this->safe_number_2($ticker, 'low', 'lower24Price'),
            'bid' => $this->safe_number_2($ticker, 'bid', 'bid1'),
            'bidVolume' => null,
            'ask' => $this->safe_number_2($ticker, 'ask', 'ask1'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $open,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'info' => $ticker,
        ), $market);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketDepth';
            if ($limit === null) {
                $limit = 100; // the spot api requires a $limit
            }
            $request['depth'] = $limit;
        } else if ($market['swap']) {
            $method = 'contractPublicGetDepthSymbol';
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "asks":array(
        //                 array("price":"49060.56","quantity":"0.099842"),
        //                 array("price":"49060.58","quantity":"0.016003"),
        //                 array("price":"49060.6","quantity":"0.023677")
        //             ),
        //             "bids":array(
        //                 array("price":"49060.45","quantity":"1.693009"),
        //                 array("price":"49060.44","quantity":"0.000843"),
        //                 array("price":"49059.98","quantity":"0.735"),
        //             ),
        //             "version":"202454074",
        //         }
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":{
        //             "asks":[
        //                 [3445.7,48379,1],
        //                 [3445.75,34994,1],
        //                 [3445.8,68634,2],
        //             ],
        //             "bids":[
        //                 [3445.55,44081,1],
        //                 [3445.5,24857,1],
        //                 [3445.45,50272,1],
        //             ],
        //             "version":2827730444,
        //             "timestamp":1634117846232
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $priceKey = $market['spot'] ? 'price' : 0;
        $amountKey = $market['spot'] ? 'quantity' : 1;
        $timestamp = $this->safe_integer($data, 'timestamp');
        $orderbook = $this->parse_order_book($data, $symbol, $timestamp, 'bids', 'asks', $priceKey, $amountKey);
        $orderbook['nonce'] = $this->safe_integer($data, 'version');
        return $orderbook;
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit; // default 100, max 100
        }
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketDeals';
        } else if ($market['swap']) {
            $method = 'contractPublicGetDealsSymbol';
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             array("trade_time":1633381766725,"trade_price":"0.068981","trade_quantity":"0.005","trade_type":"BID"),
        //             array("trade_time":1633381732705,"trade_price":"0.068979","trade_quantity":"0.006","trade_type":"BID"),
        //             array("trade_time":1633381694604,"trade_price":"0.068975","trade_quantity":"0.011","trade_type":"ASK"),
        //         )
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":array(
        //             array("p":3598.85,"v":52,"T":1,"O":2,"M":2,"t":1634169038038),
        //             array("p":3599.2,"v":15,"T":2,"O":3,"M":1,"t":1634169035603),
        //             array("p":3600.15,"v":229,"T":2,"O":1,"M":2,"t":1634169026354),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        //
        // public fetchTrades
        //
        //     spot
        //
        //     {
        //         "trade_time":1633381766725,
        //         "trade_price":"0.068981",
        //         "trade_quantity":"0.005",
        //         "trade_type":"BID"
        //     }
        //
        //     swap / contract
        //
        //     {
        //         "p":3598.85,
        //         "v":52,
        //         "T":1, // 1 buy, 2 sell
        //         "O":2, // 1 opens a position, 2 does not open a position
        //         "M":2, // self-trading, 1 yes, 2 no
        //         "t":1634169038038
        //     }
        //
        // private fetchMyTrades, fetchOrderTrades
        //
        //     {
        //         "id":"b160b8f072d9403e96289139d5544809",
        //         "symbol":"USDC_USDT",
        //         "quantity":"150",
        //         "price":"0.9997",
        //         "amount":"149.955",
        //         "fee":"0.29991",
        //         "trade_type":"ASK",
        //         "order_id":"d798765285374222990bbd14decb86cd",
        //         "is_taker":true,
        //         "fee_currency":"USDT",
        //         "create_time":1633984904000
        //     }
        //
        $timestamp = $this->safe_integer_2($trade, 'create_time', 'trade_time');
        $timestamp = $this->safe_integer($trade, 't', $timestamp);
        $marketId = $this->safe_string($trade, 'symbol');
        $market = $this->safe_market($marketId, $market, '_');
        $symbol = $market['symbol'];
        $priceString = $this->safe_string_2($trade, 'price', 'trade_price');
        $priceString = $this->safe_string($trade, 'p', $priceString);
        $amountString = $this->safe_string_2($trade, 'quantity', 'trade_quantity');
        $amountString = $this->safe_string($trade, 'v', $amountString);
        $costString = $this->safe_string($trade, 'amount');
        if ($costString === null) {
            $costString = Precise::string_mul($priceString, $amountString);
        }
        $price = $this->parse_number($priceString);
        $amount = $this->parse_number($amountString);
        $cost = $this->parse_number($costString);
        $side = $this->safe_string_2($trade, 'trade_type', 'T');
        if (($side === 'BID') || ($side === '1')) {
            $side = 'buy';
        } else if (($side === 'ASK') || ($side === '2')) {
            $side = 'sell';
        }
        $id = $this->safe_string_2($trade, 'id', 'trade_time');
        if ($id === null) {
            $id = $this->safe_string($trade, 't', $id);
            if ($id !== null) {
                $id .= '-' . $market['id'] . '-' . $amountString;
            }
        }
        $feeCost = $this->safe_number($trade, 'fee');
        $fee = null;
        if ($feeCost !== null) {
            $feeCurrencyId = $this->safe_string($trade, 'fee_currency');
            $feeCurrencyCode = $this->safe_currency_code($feeCurrencyId);
            $fee = array(
                'cost' => $feeCost,
                'currency' => $feeCurrencyCode,
            );
        }
        $orderId = $this->safe_string($trade, 'order_id');
        $isTaker = $this->safe_value($trade, 'is_taker', true);
        $takerOrMaker = $isTaker ? 'taker' : 'maker';
        return array(
            'info' => $trade,
            'id' => $id,
            'order' => $orderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $options = $this->safe_value($this->options, 'timeframes', array());
        $timeframes = $this->safe_value($options, $market['type'], array());
        $request = array(
            'symbol' => $market['id'],
            'interval' => $timeframes[$timeframe],
        );
        $method = null;
        if ($market['spot']) {
            $method = 'spotPublicGetMarketKline';
            if ($since !== null) {
                $request['start_time'] = intval($since / 1000);
            }
            if ($limit !== null) {
                $request['limit'] = $limit; // default 100
            }
        } else if ($market['swap']) {
            $method = 'contractPublicGetKlineSymbol';
            if ($since !== null) {
                $request['start'] = intval($since / 1000);
            }
            // $request['end'] = $this->seconds();
        }
        $response = yield $this->$method (array_merge($request, $params));
        //
        // spot
        //
        //     {
        //         "code":200,
        //         "data":[
        //             [1633377000,"49227.47","49186.21","49227.47","49169.48","0.5984809999999999","29434.259665989997"],
        //             [1633377060,"49186.21","49187.03","49206.64","49169.18","0.3658478","17990.651234393"],
        //             [1633377120,"49187.03","49227.2","49227.2","49174.4","0.0687651","3382.353190352"],
        //         ],
        //     }
        //
        // swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":{
        //             "time":[1634052300,1634052360,1634052420],
        //             "open":[3492.2,3491.3,3495.65],
        //             "close":[3491.3,3495.65,3495.2],
        //             "high":[3495.85,3496.55,3499.4],
        //             "low":[3491.15,3490.9,3494.2],
        //             "vol":[1740.0,351.0,314.0],
        //             "amount":[60793.623,12260.4885,10983.1375],
        //         }
        //     }
        //
        if ($market['spot']) {
            $data = $this->safe_value($response, 'data', array());
            return $this->parse_ohlcvs($data, $market, $timeframe, $since, $limit);
        } else if ($market['swap']) {
            $data = $this->safe_value($response, 'data', array());
            $result = $this->convert_trading_view_to_ohlcv($data, 'time', 'open', 'high', 'low', 'close', 'vol');
            return $this->parse_ohlcvs($result, $market, $timeframe, $since, $limit);
        }
    }

    public function parse_ohlcv($ohlcv, $market = null) {
        //
        // the ordering in spot candles is OCHLV
        //
        //     array(
        //         1633377000, // 0 timestamp (unix seconds)
        //         "49227.47", // 1 open price
        //         "49186.21", // 2 closing price
        //         "49227.47", // 3 high
        //         "49169.48", // 4 low
        //         "0.5984809999999999", // 5 base volume
        //         "29434.259665989997", // 6 quote volume
        //     )
        //
        // the ordering in swap / contract candles is OHLCV
        //
        return [
            $this->safe_timestamp($ohlcv, 0),
            $this->safe_number($ohlcv, 1),
            $this->safe_number($ohlcv, $market['spot'] ? 3 : 2),
            $this->safe_number($ohlcv, $market['spot'] ? 4 : 3),
            $this->safe_number($ohlcv, $market['spot'] ? 2 : 4),
            $this->safe_number($ohlcv, 5),
        ];
    }

    public function fetch_balance($params = array ()) {
        yield $this->load_markets();
        $defaultType = $this->safe_string_2($this->options, 'fetchBalance', 'defaultType', 'spot');
        $type = $this->safe_string($params, 'type', $defaultType);
        $spot = ($type === 'spot');
        $swap = ($type === 'swap');
        $method = null;
        if ($spot) {
            $method = 'spotPrivateGetAccountInfo';
        } else if ($swap) {
            $method = 'contractPrivateGetAccountAssets';
        }
        $query = $this->omit($params, 'type');
        $response = yield $this->$method ($query);
        //
        // $spot
        //
        //     {
        //         $code => "200",
        //         $data => {
        //             USDC => array( frozen => "0", available => "150" )
        //         }
        //     }
        //
        // $swap / contract
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":array(
        //             array("currency":"BSV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
        //             array("currency":"BCH","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
        //             array("currency":"CRV","positionMargin":0,"availableBalance":0,"cashBalance":0,"frozenBalance":0,"equity":0,"unrealized":0,"bonus":0),
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $result = array(
            'info' => $response,
            'timestamp' => null,
            'datetime' => null,
        );
        if ($spot) {
            $currencyIds = is_array($data) ? array_keys($data) : array();
            for ($i = 0; $i < count($currencyIds); $i++) {
                $currencyId = $currencyIds[$i];
                $code = $this->safe_currency_code($currencyId);
                $balance = $this->safe_value($data, $currencyId, array());
                $account = $this->account();
                $account['free'] = $this->safe_string($balance, 'available');
                $account['used'] = $this->safe_string($balance, 'frozen');
                $result[$code] = $account;
            }
        } else {
            for ($i = 0; $i < count($data); $i++) {
                $balance = $data[$i];
                $currencyId = $this->safe_string($balance, 'currency');
                $code = $this->safe_currency_code($currencyId);
                $account = $this->account();
                $account['free'] = $this->safe_string($balance, 'availableBalance');
                $account['used'] = $this->safe_string($balance, 'frozenBalance');
                $result[$code] = $account;
            }
        }
        return $this->safe_balance($result);
    }

    public function safe_network($networkId) {
        if (mb_strpos($networkId, 'BSC') !== false) {
            return 'BEP20';
        }
        $parts = explode(' ', $networkId);
        $networkId = implode('', $parts);
        $networkId = str_replace('-20', '20', $networkId);
        $networksById = array(
            'ETH' => 'ETH',
            'ERC20' => 'ERC20',
            'BEP20(BSC)' => 'BEP20',
            'TRX' => 'TRC20',
        );
        return $this->safe_string($networksById, $networkId, $networkId);
    }

    public function parse_deposit_address($depositAddress, $currency = null) {
        //
        //     array("chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"),
        //     array("chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"),
        //     array("chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"),
        //     array("chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"),
        //     array("chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU")
        //
        //
        $address = $this->safe_string($depositAddress, 'address');
        $code = $this->safe_currency_code(null, $currency);
        $networkId = $this->safe_string($depositAddress, 'chain');
        $network = $this->safe_network($networkId);
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $address,
            'tag' => null,
            'network' => $network,
            'info' => $depositAddress,
        );
    }

    public function fetch_deposit_addresses_by_network($code, $params = array ()) {
        yield $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = yield $this->spotPrivateGetAssetDepositAddressList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "currency":"USDC",
        //             "chains":array(
        //                 array("chain":"ERC-20","address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6"),
        //                 array("chain":"MATIC","address":"0x05aa3236f1970eae0f8feb17ec19435b39574d74"),
        //                 array("chain":"TRC20","address":"TGaPfhW41EXD3sAfs1grLF6DKfugfqANNw"),
        //                 array("chain":"SOL","address":"5FSpUKuh2gjw4mF89T2e7sEjzUA1SkRKjBChFqP43KhV"),
        //                 array("chain":"ALGO","address":"B3XTZND2JJTSYR7R2TQVCUDT4QSSYVAIZYDPWVBX34DGAYATBU3AUV43VU")
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $chains = $this->safe_value($data, 'chains', array());
        $depositAddresses = array();
        for ($i = 0; $i < count($chains); $i++) {
            $depositAddress = $this->parse_deposit_address($chains[$i], $currency);
            $depositAddresses[] = $depositAddress;
        }
        return $this->index_by($depositAddresses, 'network');
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $rawNetwork = $this->safe_string($params, 'network');
        $params = $this->omit($params, 'network');
        $response = yield $this->fetch_deposit_addresses_by_network($code, $params);
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string($networks, $rawNetwork, $rawNetwork);
        $result = null;
        if ($network === null) {
            $result = $this->safe_value($response, $code);
            if ($result === null) {
                $alias = $this->safe_string($networks, $code, $code);
                $result = $this->safe_value($response, $alias);
                if ($result === null) {
                    $defaultNetwork = $this->safe_string($this->options, 'defaultNetwork', 'ERC20');
                    $result = $this->safe_value($response, $defaultNetwork);
                    if ($result === null) {
                        $values = is_array($response) ? array_values($response) : array();
                        $result = $this->safe_value($values, 0);
                        if ($result === null) {
                            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find deposit address for ' . $code);
                        }
                    }
                }
            }
            return $result;
        }
        $result = $this->safe_value($response, $network);
        if ($result === null) {
            throw new InvalidAddress($this->id . ' fetchDepositAddress() cannot find ' . $network . ' deposit address for ' . $code);
        }
        return $result;
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'currency' => $currency['id'],
            // 'state' => 'state',
            // 'start_time' => $since, // default 1 day
            // 'end_time' => $this->milliseconds(),
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, maximum 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->spotPrivateGetAssetDepositList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":array(
        //                 {
        //                     "currency":"USDC",
        //                     "amount":150.0,
        //                     "fee":0.0,
        //                     "confirmations":19,
        //                     "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //                     "state":"SUCCESS",
        //                     "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //                     "require_confirmations":12,
        //                     "create_time":"2021-10-11T18:58:25.000+00:00",
        //                     "update_time":"2021-10-11T19:01:06.000+00:00"
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'result_list', array());
        return $this->parse_transactions($resultList, $code, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            // 'withdrawal_id' => '4b450616042a48c99dd45cacb4b092a7', // string
            // 'currency' => $currency['id'],
            // 'state' => 'state',
            // 'start_time' => $since, // default 1 day
            // 'end_time' => $this->milliseconds(),
            // 'page_num' => 1,
            // 'page_size' => $limit, // default 20, maximum 50
        );
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency['id'];
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->spotPrivateGetAssetWithdrawList (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":{
        //             "page_size":20,
        //             "total_page":1,
        //             "total_size":1,
        //             "page_num":1,
        //             "result_list":array(
        //                 {
        //                     "id":"4b450616042a48c99dd45cacb4b092a7",
        //                     "currency":"USDT-TRX",
        //                     "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //                     "amount":30.0,
        //                     "fee":1.0,
        //                     "remark":"this is my first withdrawal remark",
        //                     "state":"WAIT",
        //                     "create_time":"2021-10-11T20:45:08.000+00:00"
        //                 }
        //             )
        //         }
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $resultList = $this->safe_value($data, 'result_list', array());
        return $this->parse_transactions($resultList, $code, $since, $limit);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        // fetchDeposits
        //
        //     {
        //         "currency":"USDC",
        //         "amount":150.0,
        //         "fee":0.0,
        //         "confirmations":19,
        //         "address":"0x55cbd73db24eafcca97369e3f2db74b2490586e6",
        //         "state":"SUCCESS",
        //         "tx_id":"0xc65a9b09e1b71def81bf8bb3ec724c0c1b2b4c82200c8c142e4ea4c1469fd789:0",
        //         "require_confirmations":12,
        //         "create_time":"2021-10-11T18:58:25.000+00:00",
        //         "update_time":"2021-10-11T19:01:06.000+00:00"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "id":"4b450616042a48c99dd45cacb4b092a7",
        //         "currency":"USDT-TRX",
        //         "address":"TRHKnx74Gb8UVcpDCMwzZVe4NqXfkdtPak",
        //         "amount":30.0,
        //         "fee":1.0,
        //         "remark":"this is my first withdrawal remark",
        //         "state":"WAIT",
        //         "create_time":"2021-10-11T20:45:08.000+00:00"
        //     }
        //
        $id = $this->safe_string($transaction, 'id');
        $type = ($id === null) ? 'deposit' : 'withdrawal';
        $timestamp = $this->parse8601($this->safe_string($transaction, 'create_time'));
        $updated = $this->parse8601($this->safe_string($transaction, 'update_time'));
        $currencyId = $this->safe_string($transaction, 'currency');
        $network = null;
        if (($currencyId !== null) && (mb_strpos($currencyId, '-') !== false)) {
            $parts = explode('-', $currencyId);
            $currencyId = $this->safe_string($parts, 0);
            $networkId = $this->safe_string($parts, 1);
            $network = $this->safe_network($networkId);
        }
        $code = $this->safe_currency_code($currencyId, $currency);
        $status = $this->parse_transaction_status($this->safe_string($transaction, 'state'));
        $amount = $this->safe_number($transaction, 'amount');
        $address = $this->safe_string($transaction, 'address');
        $txid = $this->safe_string($transaction, 'tx_id');
        $fee = null;
        $feeCost = $this->safe_number($transaction, 'fee');
        if ($feeCost !== null) {
            $fee = array(
                'cost' => $feeCost,
                'currency' => $code,
            );
        }
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => $address,
            'tag' => null,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'network' => $network,
            'status' => $status,
            'updated' => $updated,
            'fee' => $fee,
        );
    }

    public function parse_transaction_status($status) {
        $statuses = array(
            'WAIT' => 'pending',
            'SUCCESS' => 'ok',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function fetch_position($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = yield $this->fetch_positions(array_merge($request, $params));
        $firstPosition = $this->safe_value($response, 0);
        return $firstPosition;
    }

    public function fetch_positions($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $response = yield $this->contractPrivateGetPositionOpenPositions ($params);
        //
        //     {
        //         "success" => true,
        //         "code" => 0,
        //         "data" => array(
        //             {
        //                 "positionId" => 1394650,
        //                 "symbol" => "ETH_USDT",
        //                 "positionType" => 1,
        //                 "openType" => 1,
        //                 "state" => 1,
        //                 "holdVol" => 1,
        //                 "frozenVol" => 0,
        //                 "closeVol" => 0,
        //                 "holdAvgPrice" => 1217.3,
        //                 "openAvgPrice" => 1217.3,
        //                 "closeAvgPrice" => 0,
        //                 "liquidatePrice" => 1211.2,
        //                 "oim" => 0.1290338,
        //                 "im" => 0.1290338,
        //                 "holdFee" => 0,
        //                 "realised" => -0.0073,
        //                 "leverage" => 100,
        //                 "createTime" => 1609991676000,
        //                 "updateTime" => 1609991676000,
        //                 "autoAddIm" => false
        //             }
        //         )
        //     }
        //
        // todo add parsePositions, parsePosition
        $data = $this->safe_value($response, 'data', array());
        return $data;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        if ($market['spot']) {
            return yield $this->create_spot_order($symbol, $type, $side, $amount, $price, $params);
        } else if ($market['swap']) {
            return yield $this->create_swap_order($symbol, $type, $side, $amount, $price, $params);
        }
    }

    public function create_spot_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $orderSide = null;
        if ($side === 'buy') {
            $orderSide = 'BID';
        } else if ($side === 'sell') {
            $orderSide = 'ASK';
        }
        $orderType = strtoupper($type);
        if ($orderType === 'LIMIT') {
            $orderType = 'LIMIT_ORDER';
        } else if (($orderType !== 'POST_ONLY') && ($orderType !== 'IMMEDIATE_OR_CANCEL')) {
            throw new InvalidOrder($this->id . ' createOrder does not support ' . $type . ' order $type, specify one of LIMIT, LIMIT_ORDER, POST_ONLY or IMMEDIATE_OR_CANCEL');
        }
        $request = array(
            'symbol' => $market['id'],
            'price' => $this->price_to_precision($symbol, $price),
            'quantity' => $this->amount_to_precision($symbol, $amount),
            'trade_type' => $orderSide,
            'order_type' => $orderType, // LIMIT_ORDER，POST_ONLY，IMMEDIATE_OR_CANCEL
        );
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client_order_id');
        if ($clientOrderId !== null) {
            $request['client_order_id'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'type', 'clientOrderId', 'client_order_id' ));
        $response = yield $this->spotPrivatePostOrderPlace (array_merge($request, $params));
        //
        //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
        //
        return $this->parse_order($response, $market);
    }

    public function create_swap_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $openType = $this->safe_integer($params, 'openType');
        if ($openType === null) {
            throw new ArgumentsRequired($this->id . ' createSwapOrder() requires an integer $openType parameter, 1 for isolated margin, 2 for cross margin');
        }
        if (($type !== 'limit') && ($type !== 'market') && ($type !== 1) && ($type !== 2) && ($type !== 3) && ($type !== 4) && ($type !== 5) && ($type !== 6)) {
            throw new InvalidOrder($this->id . ' createSwapOrder() order $type must either limit, $market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for $market orders or 6 to convert $market $price to current price');
        }
        if ($type === 'limit') {
            $type = 1;
        } else if ($type === 'market') {
            $type = 6;
        }
        if (($side !== 1) && ($side !== 2) && ($side !== 3) && ($side !== 4)) {
            throw new InvalidOrder($this->id . ' createSwapOrder() order $side must be 1 open long, 2 close short, 3 open short or 4 close long');
        }
        $request = array(
            'symbol' => $market['id'],
            'price' => floatval($this->price_to_precision($symbol, $price)),
            'vol' => floatval($this->amount_to_precision($symbol, $amount)),
            // 'leverage' => int, // required for isolated margin
            'side' => $side, // 1 open long, 2 close short, 3 open short, 4 close long
            //
            // supported order types
            //
            //     1 limit
            //     2 post only maker (PO)
            //     3 transact or cancel instantly (IOC)
            //     4 transact completely or cancel completely (FOK)
            //     5 $market orders
            //     6 convert $market $price to current $price
            //
            'type' => $type,
            'openType' => $openType, // 1 isolated, 2 cross
            // 'positionId' => 1394650, // long, filling in this parameter when closing a position is recommended
            // 'externalOid' => $clientOrderId,
            // 'stopLossPrice' => $this->price_to_precision($symbol, stopLossPrice),
            // 'takeProfitPrice' => $this->price_to_precision($symbol, takeProfitPrice),
        );
        if ($openType === 1) {
            $leverage = $this->safe_integer($params, 'leverage');
            if ($leverage === null) {
                throw new ArgumentsRequired($this->id . ' createSwapOrder() requires a $leverage parameter for isolated margin orders');
            }
        }
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'externalOid');
        if ($clientOrderId !== null) {
            $request['externalOid'] = $clientOrderId;
        }
        $params = $this->omit($params, array( 'clientOrderId', 'externalOid' ));
        $response = yield $this->contractPrivatePostOrderSubmit (array_merge($request, $params));
        //
        //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
        //
        return $this->parse_order($response, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $request = array();
        $clientOrderId = $this->safe_string_2($params, 'clientOrderId', 'client_order_ids');
        if ($clientOrderId !== null) {
            $params = $this->omit($params, array( 'clientOrderId', 'client_order_ids' ));
            $request['client_order_ids'] = $clientOrderId;
        } else {
            $request['order_ids'] = $id;
        }
        $response = yield $this->spotPrivateDeleteOrderCancel (array_merge($request, $params));
        //
        //    array("code":200,"data":array("965245851c444078a11a7d771323613b":"success"))
        //
        $data = $this->safe_value($response, 'data');
        return $this->parse_order($data);
    }

    public function parse_order_status($status) {
        $statuses = array(
            'NEW' => 'open',
            'FILLED' => 'closed',
            'PARTIALLY_FILLED' => 'open',
            'CANCELED' => 'canceled',
            'PARTIALLY_CANCELED' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        //
        // createOrder
        //
        // spot
        //
        //     array("code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4")
        //
        // swap / contract
        //
        //     array( "success" => true, "code" => 0, "data" => 102057569836905984 )
        //
        // fetchOpenOrders
        //
        //     {
        //         "id":"965245851c444078a11a7d771323613b",
        //         "symbol":"ETH_USDT",
        //         "price":"3430",
        //         "quantity":"0.01",
        //         "state":"NEW",
        //         "type":"BID",
        //         "remain_quantity":"0.01",
        //         "remain_amount":"34.3",
        //         "create_time":1633989029039,
        //         "client_order_id":"",
        //         "order_type":"LIMIT_ORDER"
        //     }
        //
        // fetchClosedOrders, fetchCanceledOrders, fetchOrder
        //
        //     {
        //         "id":"d798765285374222990bbd14decb86cd",
        //         "symbol":"USDC_USDT",
        //         "price":"0.9988",
        //         "quantity":"150",
        //         "state":"FILLED", // CANCELED
        //         "type":"ASK", // BID
        //         "deal_quantity":"150",
        //         "deal_amount":"149.955",
        //         "create_time":1633984904000,
        //         "order_type":"MARKET_ORDER" // LIMIT_ORDER
        //     }
        //
        // cancelOrder
        //
        //     array("965245851c444078a11a7d771323613b":"success")
        //
        $id = $this->safe_string_2($order, 'data', 'id');
        $status = null;
        if ($id === null) {
            $keys = is_array($order) ? array_keys($order) : array();
            $id = $this->safe_string($keys, 0);
            $state = $this->safe_string($order, $id);
            if ($state === 'success') {
                $status = 'canceled';
            }
        }
        $state = $this->safe_string($order, 'state');
        $timestamp = $this->safe_integer($order, 'create_time');
        $price = $this->safe_string($order, 'price');
        $amount = $this->safe_string($order, 'quantity');
        $remaining = $this->safe_string($order, 'remain_quantity');
        $filled = $this->safe_string($order, 'deal_quantity');
        $marketId = $this->safe_string($order, 'symbol');
        $symbol = $this->safe_symbol($marketId, $market, '_');
        $side = null;
        $bidOrAsk = $this->safe_string($order, 'type');
        if ($bidOrAsk === 'BID') {
            $side = 'buy';
        } else if ($bidOrAsk === 'ASK') {
            $side = 'sell';
        }
        $status = $this->parse_order_status($state);
        $clientOrderId = $this->safe_string($order, 'client_order_id');
        if ($clientOrderId === '') {
            $clientOrderId = null;
        }
        $orderType = $this->safe_string_lower($order, 'order_type');
        if ($orderType !== null) {
            $orderType = str_replace('_order', '', $orderType);
        }
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $orderType,
            'timeInForce' => null,
            'side' => $side,
            'price' => $price,
            'stopPrice' => null,
            'average' => null,
            'amount' => $amount,
            'cost' => null,
            'filled' => $filled,
            'remaining' => $remaining,
            'fee' => null,
            'trades' => null,
            'info' => $order,
        ), $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOpenOrders() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'start_time' => $since,
            // 'limit' => $limit, // default 50, max 1000
            // 'trade_type' => 'BID', // BID / ASK
        );
        $response = yield $this->spotPrivateGetOrderOpenOrders (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             array(
        //                 "id":"965245851c444078a11a7d771323613b",
        //                 "symbol":"ETH_USDT",
        //                 "price":"3430",
        //                 "quantity":"0.01",
        //                 "state":"NEW",
        //                 "type":"BID",
        //                 "remain_quantity":"0.01",
        //                 "remain_amount":"34.3",
        //                 "create_time":1633989029039,
        //                 "client_order_id":"",
        //                 "order_type":"LIMIT_ORDER"
        //             ),
        //             {
        //                 "id":"2ff3163e8617443cb9c6fc19d42b1ca4",
        //                 "symbol":"ETH_USDT",
        //                 "price":"3420",
        //                 "quantity":"0.01",
        //                 "state":"NEW",
        //                 "type":"BID",
        //                 "remain_quantity":"0.01",
        //                 "remain_amount":"34.2",
        //                 "create_time":1633988662382,
        //                 "client_order_id":"",
        //                 "order_type":"LIMIT_ORDER"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        yield $this->load_markets();
        $request = array(
            'order_ids' => $id,
        );
        $response = yield $this->spotPrivateGetOrderQuery (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "id":"2ff3163e8617443cb9c6fc19d42b1ca4",
        //                 "symbol":"ETH_USDT",
        //                 "price":"3420",
        //                 "quantity":"0.01",
        //                 "state":"CANCELED",
        //                 "type":"BID",
        //                 "deal_quantity":"0",
        //                 "deal_amount":"0",
        //                 "create_time":1633988662000,
        //                 "order_type":"LIMIT_ORDER"
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        $firstOrder = $this->safe_value($data, 0);
        if ($firstOrder === null) {
            throw new OrderNotFound($this->id . ' fetchOrder() could not find the order $id ' . $id);
        }
        return $this->parse_order($firstOrder);
    }

    public function fetch_orders_by_state($state, $symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchOrdersByState requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'start_time' => $since, // default 7 days, max 30 days
            // 'limit' => $limit, // default 50, max 1000
            // 'trade_type' => 'BID', // BID / ASK
            'states' => $state, // NEW, FILLED, PARTIALLY_FILLED, CANCELED, PARTIALLY_CANCELED
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        $response = yield $this->spotPrivateGetOrderList (array_merge($request, $params));
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_orders($data, $market, $since, $limit);
    }

    public function fetch_canceled_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return yield $this->fetch_orders_by_state('CANCELED', $symbol, $since, $limit, $params);
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        return yield $this->fetch_orders_by_state('FILLED', $symbol, $since, $limit, $params);
    }

    public function cancel_all_orders($symbol = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = yield $this->spotPrivateDeleteOrderCancelBySymbol (array_merge($request, $params));
        //
        //     {
        //         "code" => 200,
        //         "data" => array(
        //             array(
        //                 "msg" => "success",
        //                 "order_id" => "75ecf99feef04538b78e4622beaba6eb",
        //                 "client_order_id" => "a9329e86f2094b0d8b58e92c25029554"
        //             ),
        //             array(
        //                 "msg" => "success",
        //                 "order_id" => "139413c48f8b4c018f452ce796586bcf"
        //             ),
        //             {
        //                 "msg" => "success",
        //                 "order_id" => "b58ef34c570e4917981f276d44091484"
        //             }
        //         )
        //     }
        //
        return $response;
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'start_time' => $since, // default 7 days, max 30 days
            // 'limit' => $limit, // default 50, max 1000
        );
        if ($since !== null) {
            $request['start_time'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = yield $this->spotPrivateGetOrderDeals (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "id":"b160b8f072d9403e96289139d5544809",
        //                 "symbol":"USDC_USDT",
        //                 "quantity":"150",
        //                 "price":"0.9997",
        //                 "amount":"149.955",
        //                 "fee":"0.29991",
        //                 "trade_type":"ASK",
        //                 "order_id":"d798765285374222990bbd14decb86cd",
        //                 "is_taker":true,
        //                 "fee_currency":"USDT",
        //                 "create_time":1633984904000
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function fetch_order_trades($id, $symbol = null, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market($symbol);
        }
        $request = array(
            'order_id' => $id,
        );
        $response = yield $this->spotPrivateGetOrderDealDetail (array_merge($request, $params));
        //
        //     {
        //         "code":200,
        //         "data":array(
        //             {
        //                 "id":"b160b8f072d9403e96289139d5544809",
        //                 "symbol":"USDC_USDT",
        //                 "quantity":"150",
        //                 "price":"0.9997",
        //                 "amount":"149.955",
        //                 "fee":"0.29991",
        //                 "trade_type":"ASK",
        //                 "order_id":"d798765285374222990bbd14decb86cd",
        //                 "is_taker":true,
        //                 "fee_currency":"USDT",
        //                 "create_time":1633984904000
        //             }
        //         )
        //     }
        //
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_trades($data, $market, $since, $limit);
    }

    public function modify_margin_helper($symbol, $amount, $addOrReduce, $params = array ()) {
        $positionId = $this->safe_integer($params, 'positionId');
        if ($positionId === null) {
            throw new ArgumentsRequired($this->id . ' modifyMarginHelper() requires a $positionId parameter');
        }
        yield $this->load_markets();
        $request = array(
            'positionId' => $positionId,
            'amount' => $amount,
            'type' => $addOrReduce,
        );
        $response = yield $this->contractPrivatePostPositionChangeMargin (array_merge($request, $params));
        //
        //     {
        //         "success" => true,
        //         "code" => 0
        //     }
        return $response;
    }

    public function reduce_margin($symbol, $amount, $params = array ()) {
        return yield $this->modify_margin_helper($symbol, $amount, 'SUB', $params);
    }

    public function add_margin($symbol, $amount, $params = array ()) {
        return yield $this->modify_margin_helper($symbol, $amount, 'ADD', $params);
    }

    public function set_leverage($leverage, $symbol = null, $params = array ()) {
        $positionId = $this->safe_integer($params, 'positionId');
        if ($positionId === null) {
            throw new ArgumentsRequired($this->id . ' setLeverage() requires a $positionId parameter');
        }
        yield $this->load_markets();
        $request = array(
            'positionId' => $positionId,
            'leverage' => $leverage,
        );
        return yield $this->contractPrivatePostPositionChangeLeverage (array_merge($request, $params));
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        list($tag, $params) = $this->handle_withdraw_tag_and_params($tag, $params);
        $networks = $this->safe_value($this->options, 'networks', array());
        $network = $this->safe_string_2($params, 'network', 'chain'); // this line allows the user to specify either ERC20 or ETH
        $network = $this->safe_string($networks, $network, $network); // handle ETH > ERC-20 alias
        $this->check_address($address);
        yield $this->load_markets();
        $currency = $this->currency($code);
        if ($tag !== null) {
            $address .= ':' . $tag;
        }
        $request = array(
            'currency' => $currency['id'],
            'address' => $address,
            'amount' => $amount,
        );
        if ($network !== null) {
            $request['chain'] = $network;
            $params = $this->omit($params, array( 'network', 'chain' ));
        }
        $response = yield $this->spotPrivatePostAssetWithdraw (array_merge($request, $params));
        $data = $this->safe_value($response, 'data', array());
        return $this->parse_transaction($data, $currency);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        list($section, $access) = $api;
        $url = $this->urls['api'][$section][$access] . '/' . $this->implode_params($path, $params);
        $params = $this->omit($params, $this->extract_params($path));
        if ($access === 'public') {
            if ($params) {
                $url .= '?' . $this->urlencode($params);
            }
        } else {
            $this->check_required_credentials();
            $timestamp = (string) $this->milliseconds();
            $auth = '';
            $headers = array(
                'ApiKey' => $this->apiKey,
                'Request-Time' => $timestamp,
                'Content-Type' => 'application/json',
            );
            if ($method === 'POST') {
                $auth = $this->json($params);
                $body = $auth;
            } else {
                $params = $this->keysort($params);
                if ($params) {
                    $auth .= $this->urlencode($params);
                    $url .= '?' . $auth;
                }
            }
            $auth = $this->apiKey . $timestamp . $auth;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
            $headers['Signature'] = $signature;
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return;
        }
        //     array("code":10232,"msg":"The currency not exist")
        //     array("code":10216,"msg":"No available deposit address")
        //
        //     {
        //         "success":true,
        //         "code":0,
        //         "data":1634095541710
        //     }
        //
        $success = $this->safe_value($response, 'success', false);
        if ($success === true) {
            return;
        }
        $responseCode = $this->safe_string($response, 'code');
        if (($responseCode !== '200') && ($responseCode !== '0')) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $responseCode, $feedback);
            throw new ExchangeError($feedback);
        }
    }

    public function fetch_funding_rate_history($symbol = null, $since = null, $limit = null, $params = array ()) {
        //
        // Gets a history of funding $rates with their timestamps
        //  (param) $symbol => Future currency pair
        //  (param) $limit => mexc $limit is page_size default 20, maximum is 100
        //  (param) $since => not used by mexc
        //  (param) $params => Object containing more $params for the $request
        //  return => [array($symbol, fundingRate, $timestamp, dateTime)]
        //
        if ($symbol === null) {
            throw new ArgumentsRequired($this->id . ' fetchFundingRateHistory() requires a $symbol argument');
        }
        yield $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            // 'page_size' => $limit, // optional
            // 'page_num' => 1, // optional, current page number, default is 1
        );
        if ($limit !== null) {
            $request['page_size'] = $limit;
        }
        $response = yield $this->contractPublicGetFundingRateHistory (array_merge($request, $params));
        //
        // {
        //     "success" => true,
        //     "code" => 0,
        //     "data" => {
        //         "pageSize" => 2,
        //         "totalCount" => 21,
        //         "totalPage" => 11,
        //         "currentPage" => 1,
        //         "resultList" => array(
        //             array(
        //                 "symbol" => "BTC_USDT",
        //                 "fundingRate" => 0.000266,
        //                 "settleTime" => 1609804800000
        //             ),
        //             {
        //                 "symbol" => "BTC_USDT",
        //                 "fundingRate" => 0.00029,
        //                 "settleTime" => 1609776000000
        //             }
        //         )
        //     }
        // }
        //
        $data = $this->safe_value($response, 'data');
        $result = $this->safe_value($data, 'resultList');
        $rates = array();
        for ($i = 0; $i < count($result); $i++) {
            $entry = $result[$i];
            $marketId = $this->safe_string($entry, 'symbol');
            $symbol = $this->safe_symbol($marketId);
            $timestamp = $this->safe_string($entry, 'settleTime');
            $rates[] = array(
                'info' => $entry,
                'symbol' => $symbol,
                'fundingRate' => $this->safe_number($entry, 'fundingRate'),
                'timestamp' => $timestamp,
                'datetime' => $this->iso8601($timestamp),
            );
        }
        $sorted = $this->sort_by($rates, 'timestamp');
        return $this->filter_by_symbol_since_limit($sorted, $symbol, $since, $limit);
    }
}
