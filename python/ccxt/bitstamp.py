# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.errors import InvalidNonce
from ccxt.base.precise import Precise


class bitstamp(Exchange):

    def describe(self):
        return self.deep_extend(super(bitstamp, self).describe(), {
            'id': 'bitstamp',
            'name': 'Bitstamp',
            'countries': ['GB'],
            'rateLimit': 1000,
            'version': 'v2',
            'userAgent': self.userAgents['chrome'],
            'pro': True,
            'has': {
                'cancelAllOrders': True,
                'cancelOrder': True,
                'CORS': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchBorrowRate': False,
                'fetchBorrowRates': False,
                'fetchCurrencies': True,
                'fetchDepositAddress': True,
                'fetchFundingFees': True,
                'fetchIndexOHLCV': False,
                'fetchLedger': True,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchPremiumIndexOHLCV': False,
                'fetchTicker': True,
                'fetchTrades': True,
                'fetchTradingFee': True,
                'fetchTradingFees': True,
                'fetchTransactions': True,
                'fetchWithdrawals': True,
                'withdraw': True,
            },
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                'api': {
                    'public': 'https://www.bitstamp.net/api',
                    'private': 'https://www.bitstamp.net/api',
                },
                'www': 'https://www.bitstamp.net',
                'doc': 'https://www.bitstamp.net/api',
            },
            'timeframes': {
                '1m': '60',
                '3m': '180',
                '5m': '300',
                '15m': '900',
                '30m': '1800',
                '1h': '3600',
                '2h': '7200',
                '4h': '14400',
                '6h': '21600',
                '12h': '43200',
                '1d': '86400',
                '1w': '259200',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'public': {
                    'get': [
                        'ohlc/{pair}/',
                        'order_book/{pair}/',
                        'ticker_hour/{pair}/',
                        'ticker/{pair}/',
                        'transactions/{pair}/',
                        'trading-pairs-info/',
                    ],
                },
                'private': {
                    'post': [
                        'balance/',
                        'balance/{pair}/',
                        'bch_withdrawal/',
                        'bch_address/',
                        'user_transactions/',
                        'user_transactions/{pair}/',
                        'open_orders/all/',
                        'open_orders/{pair}/',
                        'order_status/',
                        'cancel_order/',
                        'cancel_all_orders/',
                        'cancel_all_orders/{pair}/',
                        'buy/{pair}/',
                        'buy/market/{pair}/',
                        'buy/instant/{pair}/',
                        'sell/{pair}/',
                        'sell/market/{pair}/',
                        'sell/instant/{pair}/',
                        'btc_withdrawal/',
                        'btc_address/',
                        'ripple_withdrawal/',
                        'ripple_address/',
                        'ltc_withdrawal/',
                        'ltc_address/',
                        'eth_withdrawal/',
                        'eth_address/',
                        'xrp_withdrawal/',
                        'xrp_address/',
                        'xlm_withdrawal/',
                        'xlm_address/',
                        'pax_withdrawal/',
                        'pax_address/',
                        'link_withdrawal/',
                        'link_address/',
                        'usdc_withdrawal/',
                        'usdc_address/',
                        'omg_withdrawal/',
                        'omg_address/',
                        'dai_withdrawal/',
                        'dai_address/',
                        'knc_withdrawal/',
                        'knc_address/',
                        'mkr_withdrawal/',
                        'mkr_address/',
                        'zrx_withdrawal/',
                        'zrx_address/',
                        'gusd_withdrawal/',
                        'gusd_address/',
                        'aave_withdrawal/',
                        'aave_address/',
                        'bat_withdrawal/',
                        'bat_address/',
                        'uma_withdrawal/',
                        'uma_address/',
                        'snx_withdrawal/',
                        'snx_address/',
                        'uni_withdrawal/',
                        'uni_address/',
                        'yfi_withdrawal/',
                        'yfi_address',
                        'audio_withdrawal/',
                        'audio_address/',
                        'crv_withdrawal/',
                        'crv_address/',
                        'algo_withdrawal/',
                        'algo_address/',
                        'comp_withdrawal/',
                        'comp_address/',
                        'grt_withdrawal',
                        'grt_address/',
                        'usdt_withdrawal/',
                        'usdt_address/',
                        'eurt_withdrawal/',
                        'eurt_address/',
                        'matic_withdrawal/',
                        'matic_address/',
                        'sushi_withdrawal/',
                        'sushi_address/',
                        'chz_withdrawal/',
                        'chz_address/',
                        'enj_withdrawal/',
                        'enj_address/',
                        'alpha_withdrawal/',
                        'alpha_address/',
                        'ftt_withdrawal/',
                        'ftt_address/',
                        'storj_withdrawal/',
                        'storj_address/',
                        'axs_withdrawal/',
                        'axs_address/',
                        'sand_withdrawal/',
                        'sand_address/',
                        'hbar_withdrawal/',
                        'hbar_address/',
                        'rgt_withdrawal/',
                        'rgt_address/',
                        'fet_withdrawal/',
                        'fet_address/',
                        'skl_withdrawal/',
                        'skl_address/',
                        'cel_withdrawal/',
                        'cel_address/',
                        'sxp_withdrawal/',
                        'sxp_address/',
                        'ada_withdrawal/',
                        'ada_address/',
                        'slp_withdrawal/',
                        'slp_address/',
                        'ftm_withdrawal/',
                        'ftm_address/',
                        'perp_withdrawal/',
                        'perp_address/',
                        'dydx_withdrawal/',
                        'dydx_address/',
                        'gala_withdrawal/',
                        'gala_address/',
                        'shib_withdrawal/',
                        'shib_address/',
                        'transfer-to-main/',
                        'transfer-from-main/',
                        'withdrawal-requests/',
                        'withdrawal/open/',
                        'withdrawal/status/',
                        'withdrawal/cancel/',
                        'liquidation_address/new/',
                        'liquidation_address/info/',
                        'btc_unconfirmed/',
                        'websockets_token/',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'taker': self.parse_number('0.005'),
                    'maker': self.parse_number('0.005'),
                    'tiers': {
                        'taker': [
                            [self.parse_number('0'), self.parse_number('0.005')],
                            [self.parse_number('20000'), self.parse_number('0.0025')],
                            [self.parse_number('100000'), self.parse_number('0.0024')],
                            [self.parse_number('200000'), self.parse_number('0.0022')],
                            [self.parse_number('400000'), self.parse_number('0.0020')],
                            [self.parse_number('600000'), self.parse_number('0.0015')],
                            [self.parse_number('1000000'), self.parse_number('0.0014')],
                            [self.parse_number('2000000'), self.parse_number('0.0013')],
                            [self.parse_number('4000000'), self.parse_number('0.0012')],
                            [self.parse_number('20000000'), self.parse_number('0.0011')],
                            [self.parse_number('50000000'), self.parse_number('0.0010')],
                            [self.parse_number('100000000'), self.parse_number('0.0007')],
                            [self.parse_number('500000000'), self.parse_number('0.0005')],
                            [self.parse_number('2000000000'), self.parse_number('0.0003')],
                            [self.parse_number('6000000000'), self.parse_number('0.0001')],
                            [self.parse_number('20000000000'), self.parse_number('0.00005')],
                            [self.parse_number('20000000001'), self.parse_number('0')],
                        ],
                        'maker': [
                            [self.parse_number('0'), self.parse_number('0.005')],
                            [self.parse_number('20000'), self.parse_number('0.0025')],
                            [self.parse_number('100000'), self.parse_number('0.0024')],
                            [self.parse_number('200000'), self.parse_number('0.0022')],
                            [self.parse_number('400000'), self.parse_number('0.0020')],
                            [self.parse_number('600000'), self.parse_number('0.0015')],
                            [self.parse_number('1000000'), self.parse_number('0.0014')],
                            [self.parse_number('2000000'), self.parse_number('0.0013')],
                            [self.parse_number('4000000'), self.parse_number('0.0012')],
                            [self.parse_number('20000000'), self.parse_number('0.0011')],
                            [self.parse_number('50000000'), self.parse_number('0.0010')],
                            [self.parse_number('100000000'), self.parse_number('0.0007')],
                            [self.parse_number('500000000'), self.parse_number('0.0005')],
                            [self.parse_number('2000000000'), self.parse_number('0.0003')],
                            [self.parse_number('6000000000'), self.parse_number('0.0001')],
                            [self.parse_number('20000000000'), self.parse_number('0.00005')],
                            [self.parse_number('20000000001'), self.parse_number('0')],
                        ],
                    },
                },
                'funding': {
                    'tierBased': False,
                    'percentage': False,
                    'withdraw': {},
                    'deposit': {
                        'BTC': 0,
                        'BCH': 0,
                        'LTC': 0,
                        'ETH': 0,
                        'XRP': 0,
                        'XLM': 0,
                        'PAX': 0,
                        'USD': 7.5,
                        'EUR': 0,
                    },
                },
            },
            'exceptions': {
                'exact': {
                    'No permission found': PermissionDenied,
                    'API key not found': AuthenticationError,
                    'IP address not allowed': PermissionDenied,
                    'Invalid nonce': InvalidNonce,
                    'Invalid signature': AuthenticationError,
                    'Authentication failed': AuthenticationError,
                    'Missing key, signature and nonce parameters': AuthenticationError,
                    'Your account is frozen': PermissionDenied,
                    'Please update your profile with your FATCA information, before using API.': PermissionDenied,
                    'Order not found': OrderNotFound,
                    'Price is more than 20% below market price.': InvalidOrder,
                    'Bitstamp.net is under scheduled maintenance.': OnMaintenance,  # {"error": "Bitstamp.net is under scheduled maintenance. We'll be back soon."}
                    'Order could not be placed.': ExchangeNotAvailable,  # Order could not be placed(perhaps due to internal error or trade halt). Please retry placing order.
                    'Invalid offset.': BadRequest,
                },
                'broad': {
                    'Minimum order size is': InvalidOrder,  # Minimum order size is 5.0 EUR.
                    'Check your account balance for details.': InsufficientFunds,  # You have only 0.00100000 BTC available. Check your account balance for details.
                    'Ensure self value has at least': InvalidAddress,  # Ensure self value has at least 25 characters(it has 4).
                },
            },
        })

    def fetch_markets(self, params={}):
        response = self.fetch_markets_from_cache(params)
        result = []
        for i in range(0, len(response)):
            market = response[i]
            name = self.safe_string(market, 'name')
            base, quote = name.split('/')
            baseId = base.lower()
            quoteId = quote.lower()
            base = self.safe_currency_code(base)
            quote = self.safe_currency_code(quote)
            symbol = base + '/' + quote
            marketId = baseId + '_' + quoteId
            id = self.safe_string(market, 'url_symbol')
            amountPrecisionString = self.safe_string(market, 'base_decimals')
            pricePrecisionString = self.safe_string(market, 'counter_decimals')
            amountLimit = self.parse_precision(amountPrecisionString)
            priceLimit = self.parse_precision(pricePrecisionString)
            precision = {
                'amount': int(amountPrecisionString),
                'price': int(pricePrecisionString),
            }
            minimumOrder = self.safe_string(market, 'minimum_order')
            parts = minimumOrder.split(' ')
            cost = parts[0]
            # cost, currency = market['minimum_order'].split(' ')
            trading = self.safe_string(market, 'trading')
            active = (trading == 'Enabled')
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'marketId': marketId,
                'info': market,
                'type': 'spot',
                'spot': True,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': self.parse_number(amountLimit),
                        'max': None,
                    },
                    'price': {
                        'min': self.parse_number(priceLimit),
                        'max': None,
                    },
                    'cost': {
                        'min': self.parse_number(cost),
                        'max': None,
                    },
                },
            })
        return result

    def construct_currency_object(self, id, code, name, precision, minCost, originalPayload):
        currencyType = 'crypto'
        description = self.describe()
        if self.is_fiat(code):
            currencyType = 'fiat'
        return {
            'id': id,
            'code': code,
            'info': originalPayload,  # the original payload
            'type': currencyType,
            'name': name,
            'active': True,
            'fee': self.safe_number(description['fees']['funding']['withdraw'], code),
            'precision': precision,
            'limits': {
                'amount': {
                    'min': math.pow(10, -precision),
                    'max': None,
                },
                'price': {
                    'min': math.pow(10, -precision),
                    'max': None,
                },
                'cost': {
                    'min': minCost,
                    'max': None,
                },
                'withdraw': {
                    'min': None,
                    'max': None,
                },
            },
        }

    def fetch_markets_from_cache(self, params={}):
        # self method is now redundant
        # currencies are now fetched before markets
        options = self.safe_value(self.options, 'fetchMarkets', {})
        timestamp = self.safe_integer(options, 'timestamp')
        expires = self.safe_integer(options, 'expires', 1000)
        now = self.milliseconds()
        if (timestamp is None) or ((now - timestamp) > expires):
            response = self.publicGetTradingPairsInfo(params)
            self.options['fetchMarkets'] = self.extend(options, {
                'response': response,
                'timestamp': now,
            })
        return self.safe_value(self.options['fetchMarkets'], 'response')

    def fetch_currencies(self, params={}):
        response = self.fetch_markets_from_cache(params)
        result = {}
        for i in range(0, len(response)):
            market = response[i]
            name = self.safe_string(market, 'name')
            base, quote = name.split('/')
            baseId = base.lower()
            quoteId = quote.lower()
            base = self.safe_currency_code(base)
            quote = self.safe_currency_code(quote)
            description = self.safe_string(market, 'description')
            baseDescription, quoteDescription = description.split(' / ')
            minimumOrder = self.safe_string(market, 'minimum_order')
            parts = minimumOrder.split(' ')
            cost = parts[0]
            if not (base in result):
                baseDecimals = self.safe_integer(market, 'base_decimals')
                result[base] = self.construct_currency_object(baseId, base, baseDescription, baseDecimals, None, market)
            if not (quote in result):
                counterDecimals = self.safe_integer(market, 'counter_decimals')
                result[quote] = self.construct_currency_object(quoteId, quote, quoteDescription, counterDecimals, self.parse_number(cost), market)
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        request = {
            'pair': self.market_id(symbol),
        }
        response = self.publicGetOrderBookPair(self.extend(request, params))
        #
        #     {
        #         "timestamp": "1583652948",
        #         "microtimestamp": "1583652948955826",
        #         "bids": [
        #             ["8750.00", "1.33685271"],
        #             ["8749.39", "0.07700000"],
        #             ["8746.98", "0.07400000"],
        #         ]
        #         "asks": [
        #             ["8754.10", "1.51995636"],
        #             ["8754.71", "1.40000000"],
        #             ["8754.72", "2.50000000"],
        #         ]
        #     }
        #
        microtimestamp = self.safe_integer(response, 'microtimestamp')
        timestamp = int(microtimestamp / 1000)
        orderbook = self.parse_order_book(response, symbol, timestamp)
        orderbook['nonce'] = microtimestamp
        return orderbook

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        request = {
            'pair': self.market_id(symbol),
        }
        ticker = self.publicGetTickerPair(self.extend(request, params))
        timestamp = self.safe_timestamp(ticker, 'timestamp')
        vwap = self.safe_number(ticker, 'vwap')
        baseVolume = self.safe_number(ticker, 'volume')
        quoteVolume = None
        if baseVolume is not None and vwap is not None:
            quoteVolume = baseVolume * vwap
        last = self.safe_number(ticker, 'last')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_number(ticker, 'high'),
            'low': self.safe_number(ticker, 'low'),
            'bid': self.safe_number(ticker, 'bid'),
            'bidVolume': None,
            'ask': self.safe_number(ticker, 'ask'),
            'askVolume': None,
            'vwap': vwap,
            'open': self.safe_number(ticker, 'open'),
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }

    def get_currency_id_from_transaction(self, transaction):
        #
        #     {
        #         "fee": "0.00000000",
        #         "btc_usd": "0.00",
        #         "datetime": XXX,
        #         "usd": 0.0,
        #         "btc": 0.0,
        #         "eth": "0.05000000",
        #         "type": "0",
        #         "id": XXX,
        #         "eur": 0.0
        #     }
        #
        currencyId = self.safe_string_lower(transaction, 'currency')
        if currencyId is not None:
            return currencyId
        transaction = self.omit(transaction, [
            'fee',
            'price',
            'datetime',
            'type',
            'status',
            'id',
        ])
        ids = list(transaction.keys())
        for i in range(0, len(ids)):
            id = ids[i]
            if id.find('_') < 0:
                value = self.safe_number(transaction, id)
                if (value is not None) and (value != 0):
                    return id
        return None

    def get_market_from_trade(self, trade):
        trade = self.omit(trade, [
            'fee',
            'price',
            'datetime',
            'tid',
            'type',
            'order_id',
            'side',
        ])
        currencyIds = list(trade.keys())
        numCurrencyIds = len(currencyIds)
        if numCurrencyIds > 2:
            raise ExchangeError(self.id + ' getMarketFromTrade too many keys: ' + self.json(currencyIds) + ' in the trade: ' + self.json(trade))
        if numCurrencyIds == 2:
            marketId = currencyIds[0] + currencyIds[1]
            if marketId in self.markets_by_id:
                return self.markets_by_id[marketId]
            marketId = currencyIds[1] + currencyIds[0]
            if marketId in self.markets_by_id:
                return self.markets_by_id[marketId]
        return None

    def get_market_from_trades(self, trades):
        tradesBySymbol = self.index_by(trades, 'symbol')
        symbols = list(tradesBySymbol.keys())
        numSymbols = len(symbols)
        if numSymbols == 1:
            return self.markets[symbols[0]]
        return None

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #      {
        #          "date": "1637845199",
        #          "tid": "209895701",
        #          "amount": "0.00500000",
        #          "type": "0",             # Transaction type: 0 - buy; 1 - sell
        #          "price": "4451.25"
        #      }
        #
        # fetchMyTrades, trades returned within fetchOrder(private)
        #
        #      {
        #          "fee": "0.11128",
        #          "eth_usdt":  4451.25,
        #          "datetime": "2021-11-25 12:59:59.322000",
        #          "usdt": "-22.26",
        #          "order_id":  1429545880227846,
        #          "usd":  0,
        #          "btc":  0,
        #          "eth": "0.00500000",
        #          "type": "2",                    # Transaction type: 0 - deposit; 1 - withdrawal; 2 - market trade; 14 - sub account transfer; 25 - credited with staked assets; 26 - sent assets to staking; 27 - staking reward; 32 - referral reward; 35 - inter account transfer.
        #          "id":  209895701,
        #          "eur":  0
        #      }
        #
        # from fetchOrder(private)
        #
        #      {
        #          "fee": "0.11128",
        #          "price": "4451.25000000",
        #          "datetime": "2021-11-25 12:59:59.322000",
        #          "usdt": "22.25625000",
        #          "tid": 209895701,
        #          "eth": "0.00500000",
        #          "type": 2                       # Transaction type: 0 - deposit; 1 - withdrawal; 2 - market trade
        #      }
        #
        id = self.safe_string_2(trade, 'id', 'tid')
        symbol = None
        side = None
        priceString = self.safe_string(trade, 'price')
        amountString = self.safe_string(trade, 'amount')
        orderId = self.safe_string(trade, 'order_id')
        type = None
        costString = self.safe_string(trade, 'cost')
        if market is None:
            keys = list(trade.keys())
            for i in range(0, len(keys)):
                if keys[i].find('_') >= 0:
                    marketId = keys[i].replace('_', '')
                    if marketId in self.markets_by_id:
                        market = self.markets_by_id[marketId]
            # if the market is still not defined
            # try to deduce it from used keys
            if market is None:
                market = self.get_market_from_trade(trade)
        feeCostString = self.safe_string(trade, 'fee')
        feeCurrency = None
        if market is not None:
            priceString = self.safe_string(trade, market['marketId'], priceString)
            amountString = self.safe_string(trade, market['baseId'], amountString)
            costString = self.safe_string(trade, market['quoteId'], costString)
            feeCurrency = market['quote']
            symbol = market['symbol']
        timestamp = self.safe_string_2(trade, 'date', 'datetime')
        if timestamp is not None:
            if timestamp.find(' ') >= 0:
                # iso8601
                timestamp = self.parse8601(timestamp)
            else:
                # string unix epoch in seconds
                timestamp = int(timestamp)
                timestamp = timestamp * 1000
        # if it is a private trade
        if 'id' in trade:
            if amountString is not None:
                isAmountNeg = Precise.string_lt(amountString, '0')
                if isAmountNeg:
                    side = 'sell'
                    amountString = Precise.string_neg(amountString)
                else:
                    side = 'buy'
        else:
            side = self.safe_string(trade, 'type')
            if side == '1':
                side = 'sell'
            elif side == '0':
                side = 'buy'
            else:
                side = None
        if costString is not None:
            costString = Precise.string_abs(costString)
        fee = None
        if feeCostString is not None:
            fee = {
                'cost': feeCostString,
                'currency': feeCurrency,
            }
        return self.safe_trade({
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': orderId,
            'type': type,
            'side': side,
            'takerOrMaker': None,
            'price': priceString,
            'amount': amountString,
            'cost': costString,
            'fee': fee,
        }, market)

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'pair': market['id'],
            'time': 'hour',
        }
        response = self.publicGetTransactionsPair(self.extend(request, params))
        #
        #     [
        #         {
        #             date: '1551814435',
        #             tid: '83581898',
        #             price: '0.03532850',
        #             type: '1',
        #             amount: '0.85945907'
        #         },
        #         {
        #             date: '1551814434',
        #             tid: '83581896',
        #             price: '0.03532851',
        #             type: '1',
        #             amount: '11.34130961'
        #         },
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        #
        #     {
        #         "high": "9064.77",
        #         "timestamp": "1593961440",
        #         "volume": "18.49436608",
        #         "low": "9040.87",
        #         "close": "9064.77",
        #         "open": "9040.87"
        #     }
        #
        return [
            self.safe_timestamp(ohlcv, 'timestamp'),
            self.safe_number(ohlcv, 'open'),
            self.safe_number(ohlcv, 'high'),
            self.safe_number(ohlcv, 'low'),
            self.safe_number(ohlcv, 'close'),
            self.safe_number(ohlcv, 'volume'),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'pair': market['id'],
            'step': self.timeframes[timeframe],
        }
        duration = self.parse_timeframe(timeframe)
        if limit is None:
            if since is None:
                raise ArgumentsRequired(self.id + ' fetchOHLCV() requires a since argument or a limit argument')
            else:
                limit = 1000
                start = int(since / 1000)
                request['start'] = start
                request['end'] = self.sum(start, limit * duration)
                request['limit'] = limit
        else:
            if since is not None:
                start = int(since / 1000)
                request['start'] = start
                request['end'] = self.sum(start, limit * duration)
            request['limit'] = min(limit, 1000)  # min 1, max 1000
        response = self.publicGetOhlcPair(self.extend(request, params))
        #
        #     {
        #         "data": {
        #             "pair": "BTC/USD",
        #             "ohlc": [
        #                 {"high": "9064.77", "timestamp": "1593961440", "volume": "18.49436608", "low": "9040.87", "close": "9064.77", "open": "9040.87"},
        #                 {"high": "9071.59", "timestamp": "1593961500", "volume": "3.48631711", "low": "9058.76", "close": "9061.07", "open": "9064.66"},
        #                 {"high": "9067.33", "timestamp": "1593961560", "volume": "0.04142833", "low": "9061.94", "close": "9061.94", "open": "9067.33"},
        #             ],
        #         }
        #     }
        #
        data = self.safe_value(response, 'data', {})
        ohlc = self.safe_value(data, 'ohlc', [])
        return self.parse_ohlcvs(ohlc, market, timeframe, since, limit)

    def fetch_balance(self, params={}):
        self.load_markets()
        balance = self.privatePostBalance(params)
        #
        #     {
        #         "aave_available": "0.00000000",
        #         "aave_balance": "0.00000000",
        #         "aave_reserved": "0.00000000",
        #         "aave_withdrawal_fee": "0.07000000",
        #         "aavebtc_fee": "0.000",
        #         "aaveeur_fee": "0.000",
        #         "aaveusd_fee": "0.000",
        #         "bat_available": "0.00000000",
        #         "bat_balance": "0.00000000",
        #         "bat_reserved": "0.00000000",
        #         "bat_withdrawal_fee": "5.00000000",
        #         "batbtc_fee": "0.000",
        #         "bateur_fee": "0.000",
        #         "batusd_fee": "0.000",
        #     }
        #
        result = {
            'info': balance,
            'timestamp': None,
            'datetime': None,
        }
        codes = list(self.currencies.keys())
        for i in range(0, len(codes)):
            code = codes[i]
            currency = self.currency(code)
            currencyId = currency['id']
            account = self.account()
            account['free'] = self.safe_string(balance, currencyId + '_available')
            account['used'] = self.safe_string(balance, currencyId + '_reserved')
            account['total'] = self.safe_string(balance, currencyId + '_balance')
            result[code] = account
        return self.safe_balance(result)

    def fetch_trading_fee(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'pair': market['id'],
        }
        response = self.privatePostBalancePair(self.extend(request, params))
        return self.parse_trading_fee(response, market)

    def parse_trading_fee(self, fee, market=None):
        market = self.safe_market(None, market)
        feeString = self.safe_string(fee, market['id'] + '_fee')
        dividedFeeString = Precise.string_div(feeString, '100')
        tradeFee = self.parse_number(dividedFeeString)
        return {
            'info': fee,
            'symbol': market['symbol'],
            'maker': tradeFee,
            'taker': tradeFee,
        }

    def parse_trading_fees(self, fees):
        result = {'info': fees}
        symbols = self.symbols
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            market = self.market(symbol)
            fee = self.parse_trading_fee(fees, market)
            result[symbol] = fee
        return result

    def fetch_trading_fees(self, params={}):
        self.load_markets()
        response = self.privatePostBalance(params)
        return self.parse_trading_fees(response)

    def parse_funding_fees(self, balance):
        withdraw = {}
        ids = list(balance.keys())
        for i in range(0, len(ids)):
            id = ids[i]
            if id.find('_withdrawal_fee') >= 0:
                currencyId = id.split('_')[0]
                code = self.safe_currency_code(currencyId)
                withdraw[code] = self.safe_number(balance, id)
        return {
            'info': balance,
            'withdraw': withdraw,
            'deposit': {},
        }

    def fetch_funding_fees(self, params={}):
        self.load_markets()
        balance = self.privatePostBalance(params)
        return self.parse_funding_fees(balance)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        method = 'privatePost' + self.capitalize(side)
        request = {
            'pair': market['id'],
            'amount': self.amount_to_precision(symbol, amount),
        }
        if type == 'market':
            method += 'Market'
        elif type == 'instant':
            method += 'Instant'
        else:
            request['price'] = self.price_to_precision(symbol, price)
        method += 'Pair'
        clientOrderId = self.safe_string_2(params, 'client_order_id', 'clientOrderId')
        if clientOrderId is not None:
            request['client_order_id'] = clientOrderId
            params = self.omit(params, ['client_order_id', 'clientOrderId'])
        response = getattr(self, method)(self.extend(request, params))
        order = self.parse_order(response, market)
        return self.extend(order, {
            'type': type,
        })

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'id': id,
        }
        return self.privatePostCancelOrder(self.extend(request, params))

    def cancel_all_orders(self, symbol=None, params={}):
        self.load_markets()
        market = None
        request = {}
        method = 'privatePostCancelAllOrders'
        if symbol is not None:
            market = self.market(symbol)
            request['pair'] = market['id']
            method = 'privatePostCancelAllOrdersPair'
        return getattr(self, method)(self.extend(request, params))

    def parse_order_status(self, status):
        statuses = {
            'In Queue': 'open',
            'Open': 'open',
            'Finished': 'closed',
            'Canceled': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def fetch_order_status(self, id, symbol=None, params={}):
        self.load_markets()
        clientOrderId = self.safe_value_2(params, 'client_order_id', 'clientOrderId')
        request = {}
        if clientOrderId is not None:
            request['client_order_id'] = clientOrderId
            params = self.omit(params, ['client_order_id', 'clientOrderId'])
        else:
            request['id'] = id
        response = self.privatePostOrderStatus(self.extend(request, params))
        return self.parse_order_status(self.safe_string(response, 'status'))

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        clientOrderId = self.safe_value_2(params, 'client_order_id', 'clientOrderId')
        request = {}
        if clientOrderId is not None:
            request['client_order_id'] = clientOrderId
            params = self.omit(params, ['client_order_id', 'clientOrderId'])
        else:
            request['id'] = id
        response = self.privatePostOrderStatus(self.extend(request, params))
        #
        #      {
        #          "status": "Finished",
        #          "id": 1429545880227846,
        #          "amount_remaining": "0.00000000",
        #          "transactions": [
        #              {
        #                  "fee": "0.11128",
        #                  "price": "4451.25000000",
        #                  "datetime": "2021-11-25 12:59:59.322000",
        #                  "usdt": "22.25625000",
        #                  "tid": 209895701,
        #                  "eth": "0.00500000",
        #                  "type": 2
        #              }
        #         ]
        #     }
        #
        return self.parse_order(response, market)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        method = 'privatePostUserTransactions'
        market = None
        if symbol is not None:
            market = self.market(symbol)
            request['pair'] = market['id']
            method += 'Pair'
        if limit is not None:
            request['limit'] = limit
        response = getattr(self, method)(self.extend(request, params))
        result = self.filter_by(response, 'type', '2')
        return self.parse_trades(result, market, since, limit)

    def fetch_transactions(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        if limit is not None:
            request['limit'] = limit
        response = self.privatePostUserTransactions(self.extend(request, params))
        #
        #     [
        #         {
        #             "fee": "0.00000000",
        #             "btc_usd": "0.00",
        #             "id": 1234567894,
        #             "usd": 0,
        #             "btc": 0,
        #             "datetime": "2018-09-08 09:00:31",
        #             "type": "1",
        #             "xrp": "-20.00000000",
        #             "eur": 0,
        #         },
        #         {
        #             "fee": "0.00000000",
        #             "btc_usd": "0.00",
        #             "id": 1134567891,
        #             "usd": 0,
        #             "btc": 0,
        #             "datetime": "2018-09-07 18:47:52",
        #             "type": "0",
        #             "xrp": "20.00000000",
        #             "eur": 0,
        #         },
        #     ]
        #
        currency = None
        if code is not None:
            currency = self.currency(code)
        transactions = self.filter_by_array(response, 'type', ['0', '1'], False)
        return self.parse_transactions(transactions, currency, since, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        if since is not None:
            request['timedelta'] = self.milliseconds() - since
        else:
            request['timedelta'] = 50000000  # use max bitstamp approved value
        response = self.privatePostWithdrawalRequests(self.extend(request, params))
        #
        #     [
        #         {
        #             status: 2,
        #             datetime: '2018-10-17 10:58:13',
        #             currency: 'BTC',
        #             amount: '0.29669259',
        #             address: 'aaaaa',
        #             type: 1,
        #             id: 111111,
        #             transaction_id: 'xxxx',
        #         },
        #         {
        #             status: 2,
        #             datetime: '2018-10-17 10:55:17',
        #             currency: 'ETH',
        #             amount: '1.11010664',
        #             address: 'aaaa',
        #             type: 16,
        #             id: 222222,
        #             transaction_id: 'xxxxx',
        #         },
        #     ]
        #
        return self.parse_transactions(response, None, since, limit)

    def parse_transaction(self, transaction, currency=None):
        #
        # fetchTransactions
        #
        #     {
        #         "fee": "0.00000000",
        #         "btc_usd": "0.00",
        #         "id": 1234567894,
        #         "usd": 0,
        #         "btc": 0,
        #         "datetime": "2018-09-08 09:00:31",
        #         "type": "1",
        #         "xrp": "-20.00000000",
        #         "eur": 0,
        #     }
        #
        # fetchWithdrawals
        #
        #     {
        #         status: 2,
        #         datetime: '2018-10-17 10:58:13',
        #         currency: 'BTC',
        #         amount: '0.29669259',
        #         address: 'aaaaa',
        #         type: 1,
        #         id: 111111,
        #         transaction_id: 'xxxx',
        #     }
        #
        #     {
        #         "id": 3386432,
        #         "type": 14,
        #         "amount": "863.21332500",
        #         "status": 2,
        #         "address": "rE1sdh25BJQ3qFwngiTBwaq3zPGGYcrjp1?dt=1455",
        #         "currency": "XRP",
        #         "datetime": "2018-01-05 15:27:55",
        #         "transaction_id": "001743B03B0C79BA166A064AC0142917B050347B4CB23BA2AB4B91B3C5608F4C"
        #     }
        #
        timestamp = self.parse8601(self.safe_string(transaction, 'datetime'))
        id = self.safe_string(transaction, 'id')
        currencyId = self.get_currency_id_from_transaction(transaction)
        code = self.safe_currency_code(currencyId, currency)
        feeCost = self.safe_number(transaction, 'fee')
        feeCurrency = None
        amount = None
        if 'amount' in transaction:
            amount = self.safe_number(transaction, 'amount')
        elif currency is not None:
            amount = self.safe_number(transaction, currency['id'], amount)
            feeCurrency = currency['code']
        elif (code is not None) and (currencyId is not None):
            amount = self.safe_number(transaction, currencyId, amount)
            feeCurrency = code
        if amount is not None:
            # withdrawals have a negative amount
            amount = abs(amount)
        status = 'ok'
        if 'status' in transaction:
            status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        type = None
        if 'type' in transaction:
            # from fetchTransactions
            rawType = self.safe_string(transaction, 'type')
            if rawType == '0':
                type = 'deposit'
            elif rawType == '1':
                type = 'withdrawal'
        else:
            # from fetchWithdrawals
            type = 'withdrawal'
        txid = self.safe_string(transaction, 'transaction_id')
        tag = None
        address = self.safe_string(transaction, 'address')
        if address is not None:
            # dt(destination tag) is embedded into the address field
            addressParts = address.split('?dt=')
            numParts = len(addressParts)
            if numParts > 1:
                address = addressParts[0]
                tag = addressParts[1]
        addressFrom = None
        addressTo = address
        tagFrom = None
        tagTo = tag
        fee = None
        if feeCost is not None:
            fee = {
                'currency': feeCurrency,
                'cost': feeCost,
                'rate': None,
            }
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'addressFrom': addressFrom,
            'addressTo': addressTo,
            'address': address,
            'tagFrom': tagFrom,
            'tagTo': tagTo,
            'tag': tag,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': None,
            'fee': fee,
        }

    def parse_transaction_status(self, status):
        # withdrawals:
        # 0(open), 1(in process), 2(finished), 3(canceled) or 4(failed).
        statuses = {
            '0': 'pending',  # Open
            '1': 'pending',  # In process
            '2': 'ok',  # Finished
            '3': 'canceled',  # Canceled
            '4': 'failed',  # Failed
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        # from fetch order:
        #   {status: 'Finished',
        #     id: 731693945,
        #     client_order_id: '',
        #     transactions:
        #     [{fee: '0.000019',
        #         price: '0.00015803',
        #         datetime: '2018-01-07 10:45:34.132551',
        #         btc: '0.0079015000000000',
        #         tid: 42777395,
        #         type: 2,
        #         xrp: '50.00000000'}]}
        #
        # partially filled order:
        #   {"id": 468646390,
        #     "client_order_id": "",
        #     "status": "Canceled",
        #     "transactions": [{
        #         "eth": "0.23000000",
        #         "fee": "0.09",
        #         "tid": 25810126,
        #         "usd": "69.8947000000000000",
        #         "type": 2,
        #         "price": "303.89000000",
        #         "datetime": "2017-11-11 07:22:20.710567"
        #     }]}
        #
        # from create order response:
        #     {
        #         price: '0.00008012',
        #         client_order_id: '',
        #         currency_pair: 'XRP/BTC',
        #         datetime: '2019-01-31 21:23:36',
        #         amount: '15.00000000',
        #         type: '0',
        #         id: '2814205012'
        #     }
        #
        id = self.safe_string(order, 'id')
        clientOrderId = self.safe_string(order, 'client_order_id')
        side = self.safe_string(order, 'type')
        if side is not None:
            side = 'sell' if (side == '1') else 'buy'
        # there is no timestamp from fetchOrder
        timestamp = self.parse8601(self.safe_string(order, 'datetime'))
        marketId = self.safe_string_lower(order, 'currency_pair')
        symbol = self.safe_symbol(marketId, market, '/')
        status = self.parse_order_status(self.safe_string(order, 'status'))
        amount = self.safe_string(order, 'amount')
        transactions = self.safe_value(order, 'transactions', [])
        price = self.safe_string(order, 'price')
        return self.safe_order({
            'id': id,
            'clientOrderId': clientOrderId,
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'lastTradeTimestamp': None,
            'status': status,
            'symbol': symbol,
            'type': None,
            'timeInForce': None,
            'postOnly': None,
            'side': side,
            'price': price,
            'stopPrice': None,
            'cost': None,
            'amount': amount,
            'filled': None,
            'remaining': None,
            'trades': transactions,
            'fee': None,
            'info': order,
            'average': None,
        }, market)

    def parse_ledger_entry_type(self, type):
        types = {
            '0': 'transaction',
            '1': 'transaction',
            '2': 'trade',
            '14': 'transfer',
        }
        return self.safe_string(types, type, type)

    def parse_ledger_entry(self, item, currency=None):
        #
        #     [
        #         {
        #             "fee": "0.00000000",
        #             "btc_usd": "0.00",
        #             "id": 1234567894,
        #             "usd": 0,
        #             "btc": 0,
        #             "datetime": "2018-09-08 09:00:31",
        #             "type": "1",
        #             "xrp": "-20.00000000",
        #             "eur": 0,
        #         },
        #         {
        #             "fee": "0.00000000",
        #             "btc_usd": "0.00",
        #             "id": 1134567891,
        #             "usd": 0,
        #             "btc": 0,
        #             "datetime": "2018-09-07 18:47:52",
        #             "type": "0",
        #             "xrp": "20.00000000",
        #             "eur": 0,
        #         },
        #     ]
        #
        type = self.parse_ledger_entry_type(self.safe_string(item, 'type'))
        if type == 'trade':
            parsedTrade = self.parse_trade(item)
            market = None
            keys = list(item.keys())
            for i in range(0, len(keys)):
                if keys[i].find('_') >= 0:
                    marketId = keys[i].replace('_', '')
                    if marketId in self.markets_by_id:
                        market = self.markets_by_id[marketId]
            # if the market is still not defined
            # try to deduce it from used keys
            if market is None:
                market = self.get_market_from_trade(item)
            direction = parsedTrade['side'] == 'in' if 'buy' else 'out'
            return {
                'id': parsedTrade['id'],
                'info': item,
                'timestamp': parsedTrade['timestamp'],
                'datetime': parsedTrade['datetime'],
                'direction': direction,
                'account': None,
                'referenceId': parsedTrade['order'],
                'referenceAccount': None,
                'type': type,
                'currency': market['base'],
                'amount': parsedTrade['amount'],
                'before': None,
                'after': None,
                'status': 'ok',
                'fee': parsedTrade['fee'],
            }
        else:
            parsedTransaction = self.parse_transaction(item, currency)
            direction = None
            if 'amount' in item:
                amount = self.safe_number(item, 'amount')
                direction = amount > 'in' if 0 else 'out'
            elif ('currency' in parsedTransaction) and parsedTransaction['currency'] is not None:
                code = parsedTransaction['currency']
                currencyId = self.safe_string(self.currencies_by_id, code, code)
                amount = self.safe_number(item, currencyId)
                direction = amount > 'in' if 0 else 'out'
            return {
                'id': parsedTransaction['id'],
                'info': item,
                'timestamp': parsedTransaction['timestamp'],
                'datetime': parsedTransaction['datetime'],
                'direction': direction,
                'account': None,
                'referenceId': parsedTransaction['txid'],
                'referenceAccount': None,
                'type': type,
                'currency': parsedTransaction['currency'],
                'amount': parsedTransaction['amount'],
                'before': None,
                'after': None,
                'status': parsedTransaction['status'],
                'fee': parsedTransaction['fee'],
            }

    def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        if limit is not None:
            request['limit'] = limit
        response = self.privatePostUserTransactions(self.extend(request, params))
        currency = None
        if code is not None:
            currency = self.currency(code)
        return self.parse_ledger(response, currency, since, limit)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        market = None
        self.load_markets()
        if symbol is not None:
            market = self.market(symbol)
        response = self.privatePostOpenOrdersAll(params)
        #     [
        #         {
        #             price: '0.00008012',
        #             currency_pair: 'XRP/BTC',
        #             client_order_id: '',
        #             datetime: '2019-01-31 21:23:36',
        #             amount: '15.00000000',
        #             type: '0',
        #             id: '2814205012',
        #         }
        #     ]
        #
        return self.parse_orders(response, market, since, limit, {
            'status': 'open',
            'type': 'limit',
        })

    def get_currency_name(self, code):
        return code.lower()

    def is_fiat(self, code):
        return code == 'USD' or code == 'EUR' or code == 'GBP'

    def fetch_deposit_address(self, code, params={}):
        if self.is_fiat(code):
            raise NotSupported(self.id + ' fiat fetchDepositAddress() for ' + code + ' is not supported!')
        name = self.get_currency_name(code)
        method = 'privatePost' + self.capitalize(name) + 'Address'
        response = getattr(self, method)(params)
        address = self.safe_string(response, 'address')
        tag = self.safe_string_2(response, 'memo_id', 'destination_tag')
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'network': None,
            'info': response,
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        # For fiat withdrawals please provide all required additional parameters in the 'params'
        # Check https://www.bitstamp.net/api/ under 'Open bank withdrawal' for list and description.
        tag, params = self.handle_withdraw_tag_and_params(tag, params)
        self.load_markets()
        self.check_address(address)
        request = {
            'amount': amount,
        }
        method = None
        if not self.is_fiat(code):
            name = self.get_currency_name(code)
            method = 'privatePost' + self.capitalize(name) + 'Withdrawal'
            if code == 'XRP':
                if tag is not None:
                    request['destination_tag'] = tag
            elif code == 'XLM' or code == 'HBAR':
                if tag is not None:
                    request['memo_id'] = tag
            request['address'] = address
        else:
            method = 'privatePostWithdrawalOpen'
            currency = self.currency(code)
            request['iban'] = address
            request['account_currency'] = currency['id']
        response = getattr(self, method)(self.extend(request, params))
        return {
            'info': response,
            'id': self.safe_string(response, 'id'),
        }

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api] + '/'
        url += self.version + '/'
        url += self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            self.check_required_credentials()
            xAuth = 'BITSTAMP ' + self.apiKey
            xAuthNonce = self.uuid()
            xAuthTimestamp = str(self.milliseconds())
            xAuthVersion = 'v2'
            contentType = ''
            headers = {
                'X-Auth': xAuth,
                'X-Auth-Nonce': xAuthNonce,
                'X-Auth-Timestamp': xAuthTimestamp,
                'X-Auth-Version': xAuthVersion,
            }
            if method == 'POST':
                if query:
                    body = self.urlencode(query)
                    contentType = 'application/x-www-form-urlencoded'
                    headers['Content-Type'] = contentType
                else:
                    # sending an empty POST request will trigger
                    # an API0020 error returned by the exchange
                    # therefore for empty requests we send a dummy object
                    # https://github.com/ccxt/ccxt/issues/6846
                    body = self.urlencode({'foo': 'bar'})
                    contentType = 'application/x-www-form-urlencoded'
                    headers['Content-Type'] = contentType
            authBody = body if body else ''
            auth = xAuth + method + url.replace('https://', '') + contentType + xAuthNonce + xAuthTimestamp + xAuthVersion + authBody
            signature = self.hmac(self.encode(auth), self.encode(self.secret))
            headers['X-Auth-Signature'] = signature
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return
        #
        #     {"error": "No permission found"}  # fetchDepositAddress returns self on apiKeys that don't have the permission required
        #     {"status": "error", "reason": {"__all__": ["Minimum order size is 5.0 EUR."]}}
        #     reuse of a nonce gives: {status: 'error', reason: 'Invalid nonce', code: 'API0004'}
        status = self.safe_string(response, 'status')
        error = self.safe_value(response, 'error')
        if (status == 'error') or (error is not None):
            errors = []
            if isinstance(error, basestring):
                errors.append(error)
            elif error is not None:
                keys = list(error.keys())
                for i in range(0, len(keys)):
                    key = keys[i]
                    value = self.safe_value(error, key)
                    if isinstance(value, list):
                        errors = self.array_concat(errors, value)
                    else:
                        errors.append(value)
            reason = self.safe_value(response, 'reason', {})
            if isinstance(reason, basestring):
                errors.append(reason)
            else:
                all = self.safe_value(reason, '__all__', [])
                for i in range(0, len(all)):
                    errors.append(all[i])
            code = self.safe_string(response, 'code')
            if code == 'API0005':
                raise AuthenticationError(self.id + ' invalid signature, use the uid for the main account if you have subaccounts')
            feedback = self.id + ' ' + body
            for i in range(0, len(errors)):
                value = errors[i]
                self.throw_exactly_matched_exception(self.exceptions['exact'], value, feedback)
                self.throw_broadly_matched_exception(self.exceptions['broad'], value, feedback)
            raise ExchangeError(feedback)
